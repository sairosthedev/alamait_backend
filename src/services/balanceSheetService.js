const mongoose = require('mongoose');
const TransactionEntry = require('../models/TransactionEntry');

class BalanceSheetService {
  /**
   * Generate Balance Sheet for Accrual Basis
   * Assets = Cash + AR + Property + Equipment + Prepaid
   * Liabilities = AP + Loans + Deposits + Accrued Expenses + Taxes
   * Equity = Capital + Retained Earnings (from Income Statement)
   */
  static async generateBalanceSheet(asOfDate, residence = null) {
    try {
      console.log(`üìä Generating Balance Sheet as of ${asOfDate}`);
      
      // Use all transactions up to asOfDate (balance sheet should include all historical transactions)
      const asOf = new Date(asOfDate);
      const asOfMonth = asOf.getMonth() + 1;
      const asOfYear = asOf.getFullYear();
      const monthKey = `${asOfYear}-${String(asOfMonth).padStart(2, '0')}`;
      
      // For balance sheet, we need to include:
      // 1. All accruals up to asOf date (rental_accrual, expense_accrual - these create the obligations)
      // 2. All payments up to asOf date (payment, vendor_payment - these settle the obligations)
      // 3. All other transactions up to asOf date (non-payment transactions)
      
      const accrualQuery = {
        source: { $in: ['rental_accrual', 'expense_accrual'] },
        date: { $lte: asOf },
        status: 'posted'
      };
      
      const paymentQuery = {
        source: { $in: ['payment', 'vendor_payment'] },
        date: { $lte: asOf },
        status: 'posted'
      };
      
      const otherQuery = {
        source: { $nin: ['rental_accrual', 'expense_accrual', 'payment', 'vendor_payment'] },
        date: { $lte: asOf },
        status: 'posted'
      };
      
      if (residence) {
        accrualQuery.residence = residence;
        paymentQuery.residence = residence;
        otherQuery.residence = residence;
      }
      
      // Get all relevant transactions with timeout optimization
      const [accrualEntries, paymentEntries, otherEntries] = await Promise.all([
        TransactionEntry.find(accrualQuery).sort({ date: 1 }).maxTimeMS(20000), // 20 second timeout
        TransactionEntry.find(paymentQuery).sort({ date: 1 }).maxTimeMS(20000), // 20 second timeout
        TransactionEntry.find(otherQuery).sort({ date: 1 }).maxTimeMS(20000) // 20 second timeout
      ]);
      
      const allEntries = [...accrualEntries, ...paymentEntries, ...otherEntries];
      
      // Initialize balance sheet with proper structure
      const balanceSheet = {
        asOfDate: new Date(asOfDate),
        residence: residence || 'all',
        assets: { 
          current: {}, 
          nonCurrent: {}, 
          totalCurrent: 0, 
          totalNonCurrent: 0, 
          totalAssets: 0,
          accumulatedDepreciation: 0
        },
        liabilities: { 
          current: {}, 
          nonCurrent: {}, 
          totalCurrent: 0, 
          totalNonCurrent: 0, 
          totalLiabilities: 0 
        },
        equity: { 
          capital: 0, 
          retainedEarnings: 0, 
          otherEquity: 0,
          totalEquity: 0 
        },
        workingCapital: 0,
        currentRatio: 0,
        debtToEquity: 0,
        message: 'Balance sheet generated successfully'
      };
      
      // Get ALL accounts from the database to ensure none are missing
      const Account = require('../models/Account');
      const allAccounts = await Account.find().sort({ code: 1 });
      
      console.log(`üîç Found ${allEntries.length} transaction entries and ${allAccounts.length} accounts in database`);
      
      // Debug: Show all accounts found
      console.log('üìã All accounts from database:', allAccounts.map(acc => ({ code: acc.code, name: acc.name, type: acc.type })));
      
      // Process entries to build account balances
      const accountBalances = {};
      
      // Initialize ALL accounts with zero balances first
      allAccounts.forEach(account => {
        accountBalances[account.code] = {
          code: account.code,
          name: account.name,
          type: account.type,
          debitTotal: 0,
          creditTotal: 0,
          balance: 0,
          description: account.description || '',
          category: account.category || 'Other'
        };
      });
      
      console.log(`üîç Initialized ${Object.keys(accountBalances).length} accounts from database`);
      
      // Process transaction entries to update balances
      allEntries.forEach(entry => {
        if (entry.entries && Array.isArray(entry.entries)) {
          entry.entries.forEach(lineItem => {
            const accountCode = lineItem.accountCode;
            const accountName = lineItem.accountName;
            const accountType = lineItem.accountType;
            const debit = lineItem.debit || 0;
            const credit = lineItem.credit || 0;
            
            if (accountBalances[accountCode]) {
              accountBalances[accountCode].debitTotal += debit;
              accountBalances[accountCode].creditTotal += credit;
              // Update name and type from transaction if more recent
              if (accountName) accountBalances[accountCode].name = accountName;
              if (accountType) accountBalances[accountCode].type = accountType;
            } else {
              // Create account if not found in database (fallback)
              accountBalances[accountCode] = {
                code: accountCode,
                name: accountName || `Account ${accountCode}`,
                type: accountType || 'Asset',
                debitTotal: debit,
                creditTotal: credit,
                balance: 0,
                description: '',
                category: 'Other'
              };
            }
          });
        }
      });
      
      console.log(`üîç Account balances after processing transactions:`, Object.keys(accountBalances).length);
      
      // üÜï FIX: Calculate monthSettled-based balances from the already filtered transactions
      try {
        // Calculate AR balance from the filtered transactions
        let arDebits = 0;
        let arCredits = 0;
        let cashByMonth = 0;
        let depositsTotal = 0;
        let deferredTotal = 0;
        
        // Process accrual entries (AR debits)
        accrualEntries.forEach(tx => {
          tx.entries.forEach(line => {
            if (line.accountCode && (line.accountCode.startsWith('1100-') || line.accountCode === '1100')) {
              arDebits += Number(line.debit || 0);
            }
          });
        });
        
        // Process payment entries (AR credits, cash, deposits, deferred)
        paymentEntries.forEach(tx => {
          tx.entries.forEach(line => {
            if (line.accountCode && (line.accountCode.startsWith('1100-') || line.accountCode === '1100')) {
              arCredits += Number(line.credit || 0);
            } else if (line.accountCode && line.accountCode.match(/^100[0-9]/)) {
              // Cash accounts - only include if monthSettled = current month
              if (tx.metadata?.monthSettled === monthKey) {
                cashByMonth += Number(line.debit || 0) - Number(line.credit || 0);
              }
            } else if (line.accountCode === '1000') {
              // Main cash account - only include if monthSettled = current month
              if (tx.metadata?.monthSettled === monthKey) {
                cashByMonth += Number(line.debit || 0) - Number(line.credit || 0);
              }
            } else if (line.accountCode && line.accountCode.startsWith('2020')) {
              // Deposit accounts
              depositsTotal += (line.credit || 0) - (line.debit || 0);
            } else if (line.accountCode && line.accountCode.startsWith('2200')) {
              // Deferred income accounts
              deferredTotal += (line.credit || 0) - (line.debit || 0);
            }
          });
        });
        
        const arByMonthOutstanding = arDebits - arCredits;
        
        // Override account balances with monthSettled values
        Object.values(accountBalances).forEach(account => {
          if (account.code && (account.code.startsWith('1100-') || account.code === '1100')) {
            // Override AR accounts with monthSettled calculation
            account.balance = arByMonthOutstanding;
            account.debitTotal = arDebits;
            account.creditTotal = arCredits;
          } else if (account.code && account.code.match(/^100[0-9]/)) {
            // Override cash accounts with monthSettled calculation
            account.balance = cashByMonth;
            account.debitTotal = cashByMonth;
            account.creditTotal = 0;
          } else if (account.code && account.code.startsWith('2020')) {
            // Override deposit accounts with monthSettled calculation
            account.balance = depositsTotal;
            account.debitTotal = 0;
            account.creditTotal = depositsTotal;
          } else if (account.code && account.code.startsWith('2200')) {
            // Override deferred income accounts with monthSettled calculation
            account.balance = deferredTotal;
            account.debitTotal = 0;
            account.creditTotal = deferredTotal;
          }
        });
        
        console.log(`üÜï MonthSettled reclassification for ${monthKey}: AR=${arByMonthOutstanding}, Cash=${cashByMonth}, Deposits=${depositsTotal}, Deferred=${deferredTotal}`);
      } catch (error) {
        console.error('Error reclassifying by monthSettled:', error.message);
      }
      
      // Calculate net balance for each account
      Object.values(accountBalances).forEach(account => {
        switch (account.type) {
          case 'Asset':
            account.balance = account.debitTotal - account.creditTotal;
            break;
          case 'Liability':
            account.balance = account.creditTotal - account.debitTotal;
            break;
          case 'Equity':
            account.balance = account.creditTotal - account.debitTotal;
            break;
          case 'Income':
            // Income should be positive (credit > debit means income earned)
            account.balance = Math.max(0, account.creditTotal - account.debitTotal);
            break;
          case 'Expense':
            // Expense should be positive (debit > credit means expense incurred)
            account.balance = Math.max(0, account.debitTotal - account.creditTotal);
            break;
        }
      });
      
      // Categorize into balance sheet sections with proper classification
      Object.values(accountBalances).forEach(account => {
        const balance = account.balance;
        
        // Use comprehensive category mapping to ensure all accounts are properly categorized
        const mappedCategory = this.mapAccountToCategory(account.code, account.name, account.type);
        console.log(`üîç Account ${account.code} (${account.name}): type=${account.type}, mapped=${mappedCategory}, balance=$${balance}`);
        
        switch (account.type) {
          case 'Asset':
            if (this.isCurrentAsset(account.code, account.name)) {
              balanceSheet.assets.current[account.code] = {
                name: account.name,
                balance: Math.max(0, balance),
                description: this.getAssetDescription(account.code, account.name),
                category: mappedCategory
              };
              balanceSheet.assets.totalCurrent += Math.max(0, balance);
              console.log(`‚úÖ Added to current assets: ${account.code} - ${account.name} = $${Math.max(0, balance)}`);
            } else {
              balanceSheet.assets.nonCurrent[account.code] = {
                name: account.name,
                balance: Math.max(0, balance),
                description: this.getAssetDescription(account.code, account.name),
                category: mappedCategory
              };
              balanceSheet.assets.totalNonCurrent += Math.max(0, balance);
              console.log(`‚úÖ Added to non-current assets: ${account.code} - ${account.name} = $${Math.max(0, balance)}`);
            }
            break;
            
          case 'Liability':
            if (this.isCurrentLiability(account.code, account.name)) {
              balanceSheet.liabilities.current[account.code] = {
                name: account.name,
                balance: Math.abs(balance), // Use absolute value for liabilities
                description: this.getLiabilityDescription(account.code, account.name),
                category: 'Current Liability'
              };
              balanceSheet.liabilities.totalCurrent += Math.abs(balance);
            } else {
              balanceSheet.liabilities.nonCurrent[account.code] = {
                name: account.name,
                balance: Math.abs(balance), // Use absolute value for liabilities
                description: this.getLiabilityDescription(account.code, account.name),
                category: 'Non-Current Liability'
              };
              balanceSheet.liabilities.totalNonCurrent += Math.abs(balance);
            }
            break;
            
          case 'Equity':
            if (account.code === '3000' || account.name.toLowerCase().includes('capital')) {
              balanceSheet.equity.capital = Math.abs(balance); // Use absolute value for capital
            } else if (account.name.toLowerCase().includes('retained') || account.name.toLowerCase().includes('earnings')) {
              balanceSheet.equity.retainedEarnings += Math.abs(balance); // Use absolute value for retained earnings
            } else {
              balanceSheet.equity.otherEquity += Math.abs(balance); // Use absolute value for other equity
            }
            break;
            
          case 'Income':
            // Income increases retained earnings
            balanceSheet.equity.retainedEarnings += balance;
            console.log(`üìà Income account ${account.code} (${account.name}): +$${balance.toLocaleString()} ‚Üí Retained Earnings: $${balanceSheet.equity.retainedEarnings.toLocaleString()}`);
            break;
            
          case 'Expense':
            // Expenses decrease retained earnings
            balanceSheet.equity.retainedEarnings -= balance;
            console.log(`üìâ Expense account ${account.code} (${account.name}): -$${balance.toLocaleString()} ‚Üí Retained Earnings: $${balanceSheet.equity.retainedEarnings.toLocaleString()}`);
            break;
        }
      });
      
      // AGGREGATE PARENT ACCOUNTS WITH CHILDREN (e.g., Account 2000 + child accounts)
      await this.aggregateParentChildAccounts(balanceSheet);
      
      // Debug: Show all accounts that were processed
      console.log('\nüìä BALANCE SHEET SUMMARY:');
      console.log('Current Assets:', Object.keys(balanceSheet.assets.current));
      console.log('Non-Current Assets:', Object.keys(balanceSheet.assets.nonCurrent));
      console.log('Current Liabilities:', Object.keys(balanceSheet.liabilities.current));
      console.log('Non-Current Liabilities:', Object.keys(balanceSheet.liabilities.nonCurrent));
      console.log('Equity:', Object.keys(balanceSheet.equity));
      
      // Debug: Show specific account processing for petty cash
      console.log('\nüîç PETTY CASH DEBUG:');
      const pettyCashAccounts = Object.values(accountBalances).filter(acc => 
        acc.code.startsWith('101') || acc.name.toLowerCase().includes('petty')
      );
      console.log('Petty cash accounts found:', pettyCashAccounts.map(acc => ({
        code: acc.code,
        name: acc.name,
        type: acc.type,
        balance: acc.balance,
        isCurrentAsset: this.isCurrentAsset(acc.code, acc.name)
      })));
      
      if (pettyCashAccounts.length === 0) {
        console.log('‚ùå NO PETTY CASH ACCOUNTS FOUND!');
      }
      
      // Calculate totals and ratios
      balanceSheet.assets.totalAssets = balanceSheet.assets.totalCurrent + balanceSheet.assets.totalNonCurrent;
      // Ensure liability totals are always positive
      balanceSheet.liabilities.totalLiabilities = Math.abs(balanceSheet.liabilities.totalCurrent + balanceSheet.liabilities.totalNonCurrent);
      // Ensure equity totals are always positive
      balanceSheet.equity.totalEquity = balanceSheet.equity.capital + balanceSheet.equity.retainedEarnings + balanceSheet.equity.otherEquity;
      
      // Calculate key ratios
      balanceSheet.workingCapital = balanceSheet.assets.totalCurrent - balanceSheet.liabilities.totalCurrent;
      balanceSheet.currentRatio = balanceSheet.liabilities.totalCurrent > 0 ? 
        balanceSheet.assets.totalCurrent / balanceSheet.liabilities.totalCurrent : 0;
      balanceSheet.debtToEquity = balanceSheet.equity.totalEquity > 0 ? 
        balanceSheet.liabilities.totalLiabilities / balanceSheet.equity.totalEquity : 0;
      
      // Validate accounting equation: Assets = Liabilities + Equity
      const accountingEquation = Math.abs(
        balanceSheet.assets.totalAssets - 
        (balanceSheet.liabilities.totalLiabilities + balanceSheet.equity.totalEquity)
      );
      
      if (accountingEquation > 0.01) {
        console.warn(`‚ö†Ô∏è Accounting equation imbalance: ${accountingEquation}`);
        
        // Calculate what equity should be based on Assets - Liabilities
        const calculatedEquity = balanceSheet.assets.totalAssets - balanceSheet.liabilities.totalLiabilities;
        const equityDifference = calculatedEquity - balanceSheet.equity.totalEquity;
        
        console.log(`üîç Accounting Equation Analysis:`);
        console.log(`  - Assets: $${balanceSheet.assets.totalAssets.toLocaleString()}`);
        console.log(`  - Liabilities: $${balanceSheet.liabilities.totalLiabilities.toLocaleString()}`);
        console.log(`  - Calculated Equity (Assets - Liabilities): $${calculatedEquity.toLocaleString()}`);
        console.log(`  - Actual Equity from Transactions: $${balanceSheet.equity.totalEquity.toLocaleString()}`);
        console.log(`  - Difference: $${equityDifference.toLocaleString()}`);
        
        // DO NOT auto-correct retained earnings - let it show the actual transaction-based value
        // This difference indicates either:
        // 1. Missing transactions
        // 2. Data entry errors
        // 3. Or legitimate accounting differences that need investigation
        
        balanceSheet.accountingEquation = {
          balanced: false,
          difference: accountingEquation,
          message: `Assets ‚â† Liabilities + Equity - Difference: $${equityDifference.toLocaleString()}. Retained Earnings show actual transaction values.`,
          autoCorrected: false,
          correctionAmount: 0,
          investigationRequired: true
        };
      } else {
        balanceSheet.accountingEquation = {
          balanced: true,
          difference: 0,
          message: 'Assets = Liabilities + Equity ‚úì'
        };
      }
      
      return balanceSheet;
      
    } catch (error) {
      console.error('‚ùå Error generating balance sheet:', error);
      throw error;
    }
  }

  /**
   * Generate Monthly Balance Sheet for React Component
   * This method provides the data structure expected by the React component
   */
  static async generateMonthlyBalanceSheet(year, residence = null, type = 'monthly') {
    try {
      console.log(`üìä Generating Monthly Balance Sheet for ${year}${residence ? ` for residence: ${residence}` : ' (all residences)'} - Type: ${type}`);
      
      const monthlyData = {};
      const annualSummary = {
        totalAnnualAssets: 0,
        totalAnnualLiabilities: 0,
        totalAnnualEquity: 0,
        totalAnnualCurrentAssets: 0,
        totalAnnualNonCurrentAssets: 0,
        totalAnnualCurrentLiabilities: 0,
        totalAnnualNonCurrentLiabilities: 0
      };
      
      // üöÄ OPTIMIZATION: Cache accounts once to avoid repeated database queries
      console.log(`‚ö° Caching accounts to avoid repeated database queries... [DEPLOYED]`);
      const Account = require('../models/Account');
      
      // Set longer timeout for account fetching
      const cachedAccounts = await Account.find()
        .sort({ code: 1 })
        .maxTimeMS(30000); // 30 second timeout
      console.log(`üìã Cached ${cachedAccounts.length} accounts for reuse across all months`);
      
      // üöÄ OPTIMIZATION: Pre-filter accounts to only include balance sheet relevant ones
      const balanceSheetAccounts = cachedAccounts.filter(account => 
        ['Asset', 'Liability', 'Equity'].includes(account.type)
      );
      console.log(`üìä Filtered to ${balanceSheetAccounts.length} balance sheet relevant accounts`);
      
      // üöÄ OPTIMIZATION: Process months in parallel instead of sequentially
      console.log(`‚ö° Processing all 12 months in parallel for faster generation... [DEPLOYED]`);
      
      const monthPromises = [];
      for (let month = 1; month <= 12; month++) {
        const monthEndDate = new Date(year, month, 0); // Last day of the month
        const monthKey = month;
        
        const monthPromise = (async () => {
          try {
          let monthBalanceSheet;
          
          if (type === 'monthly') {
            // Calculate monthly activity (change from previous month) - pass filtered accounts
            monthBalanceSheet = await this.generateMonthlyActivityBalanceSheet(year, month, residence, balanceSheetAccounts);
          } else {
            // Calculate cumulative balance as of month end (default behavior)
            monthBalanceSheet = await this.generateBalanceSheet(monthEndDate, residence);
          }
          
          // Structure the data as expected by the React component with enhanced structure
          monthlyData[monthKey] = {
            month: monthKey,
            monthName: monthEndDate.toLocaleDateString('en-US', { month: 'long' }),
            assets: {
              current: {
                cashAndBank: this.formatCashAndBankAccounts(monthBalanceSheet.assets.current),
                accountsReceivable: this.formatAccountsReceivable(monthBalanceSheet.assets.current),
                inventory: this.formatInventoryAccounts(monthBalanceSheet.assets.current),
                prepaidExpenses: this.formatPrepaidAccounts(monthBalanceSheet.assets.current),
                total: monthBalanceSheet.assets.totalCurrent
              },
              nonCurrent: {
                propertyPlantEquipment: this.formatFixedAssets(monthBalanceSheet.assets.nonCurrent),
                accumulatedDepreciation: monthBalanceSheet.assets.accumulatedDepreciation,
                total: monthBalanceSheet.assets.totalNonCurrent
              },
              total: monthBalanceSheet.assets.totalAssets
            },
            
            // Debug: Show what's in cashAndBank after formatting (move logs outside object construction)
            liabilities: {
              current: {
                accountsPayable: this.formatAccountsPayable(monthBalanceSheet.liabilities.current),
                accruedExpenses: this.formatAccruedExpenses(monthBalanceSheet.liabilities.current),
                tenantDeposits: this.formatTenantDeposits(monthBalanceSheet.liabilities.current),
                deferredIncome: this.formatDeferredIncome(monthBalanceSheet.liabilities.current),
                taxesPayable: this.formatTaxesPayable(monthBalanceSheet.liabilities.current),
                total: Math.abs(monthBalanceSheet.liabilities.totalCurrent)
              },
              nonCurrent: {
                longTermLoans: this.formatLongTermLoans(monthBalanceSheet.liabilities.nonCurrent),
                otherLongTermLiabilities: this.formatOtherLongTermLiabilities(monthBalanceSheet.liabilities.nonCurrent),
                total: Math.abs(monthBalanceSheet.liabilities.totalNonCurrent)
              },
              total: Math.abs(monthBalanceSheet.liabilities.totalLiabilities)
            },
            equity: {
              capital: {
                accountCode: '3000',
                accountName: 'Owner\'s Capital',
                amount: monthBalanceSheet.equity.capital // Allow negative values for equity
              },
              retainedEarnings: {
                accountCode: '3100',
                accountName: 'Retained Earnings',
                amount: monthBalanceSheet.equity.retainedEarnings // Allow negative values for equity
              },
              otherEquity: {
                accountCode: '3200',
                accountName: 'Other Equity',
                amount: monthBalanceSheet.equity.otherEquity // Allow negative values for equity
              },
              total: monthBalanceSheet.equity.totalEquity
            },
            summary: {
              totalAssets: monthBalanceSheet.assets.totalAssets,
              totalLiabilities: Math.abs(monthBalanceSheet.liabilities.totalLiabilities), // Ensure positive values for liabilities
              totalEquity: monthBalanceSheet.equity.totalEquity, // Allow negative values for equity
              workingCapital: monthBalanceSheet.workingCapital,
              currentRatio: monthBalanceSheet.currentRatio,
              debtToEquity: monthBalanceSheet.debtToEquity
            }
          };
          
          // Return structured data for parallel processing
          return {
            month,
            monthKey,
            monthData,
            monthBalanceSheet,
            annualTotals: {
              totalAssets: monthBalanceSheet.assets.totalAssets,
              totalLiabilities: Math.abs(monthBalanceSheet.liabilities.totalLiabilities),
              totalEquity: monthBalanceSheet.equity.totalEquity,
              totalCurrentAssets: monthBalanceSheet.assets.totalCurrent,
              totalNonCurrentAssets: monthBalanceSheet.assets.totalNonCurrent,
              totalCurrentLiabilities: Math.abs(monthBalanceSheet.liabilities.totalCurrent),
              totalNonCurrentLiabilities: Math.abs(monthBalanceSheet.liabilities.totalNonCurrent)
            },
            error: null
          };
          
          } catch (monthError) {
            console.error(`‚ùå Error generating balance sheet for month ${month}:`, monthError);
            return { 
              month, 
              monthKey, 
              monthData: null, 
              monthBalanceSheet: null, 
              annualTotals: null, 
              error: monthError 
            };
          }
        })();
        
        monthPromises.push(monthPromise);
      }
      
      // Wait for all months to complete with progress tracking
      console.log(`‚è≥ Waiting for all 12 months to complete...`);
      const startTime = Date.now();
      
      // Use Promise.allSettled to handle individual month failures gracefully
      const monthResults = await Promise.allSettled(monthPromises);
      
      const endTime = Date.now();
      const duration = (endTime - startTime) / 1000;
      console.log(`‚úÖ All months processed in ${duration.toFixed(2)} seconds`);
      
      // Process results from Promise.allSettled
      for (let i = 0; i < monthResults.length; i++) {
        const result = monthResults[i];
        const month = i + 1;
        const monthKey = month;
        
        if (result.status === 'rejected') {
          // Handle error case
          console.error(`‚ùå Error generating balance sheet for month ${month}:`, result.reason);
          monthlyData[monthKey] = {
            month: monthKey,
            monthName: new Date(year, month - 1, 1).toLocaleDateString('en-US', { month: 'long' }),
            assets: { 
              current: { cashAndBank: {}, accountsReceivable: {}, inventory: {}, prepaidExpenses: {}, total: 0 }, 
              nonCurrent: { propertyPlantEquipment: {}, accumulatedDepreciation: 0, total: 0 }, 
              total: 0 
            },
            liabilities: { 
              current: { accountsPayable: {}, accruedExpenses: {}, tenantDeposits: {}, taxesPayable: {}, total: 0 }, 
              nonCurrent: { longTermLoans: {}, otherLongTermLiabilities: {}, total: 0 }, 
              total: 0 
            },
            equity: { 
              capital: { accountCode: '3000', accountName: 'Owner\'s Capital', amount: 0 }, 
              retainedEarnings: { accountCode: '3100', accountName: 'Retained Earnings', amount: 0 }, 
              otherEquity: { accountCode: '3200', accountName: 'Other Equity', amount: 0 }, 
              total: 0 
            },
            summary: { 
              totalAssets: 0, 
              totalLiabilities: 0, 
              totalEquity: 0, 
              workingCapital: 0, 
              currentRatio: 0, 
              debtToEquity: 0 
            }
          };
          continue;
        }
        
        const { month: resultMonth, monthKey: resultMonthKey, monthData, monthBalanceSheet, annualTotals, error } = result.value;
        
        if (error) {
          // Handle error case from the promise result
          console.error(`‚ùå Error generating balance sheet for month ${resultMonth}:`, error);
          monthlyData[monthKey] = {
            month: monthKey,
            monthName: new Date(year, month - 1, 1).toLocaleDateString('en-US', { month: 'long' }),
            assets: {
              current: { cashAndBank: {}, accountsReceivable: {}, inventory: {}, prepaidExpenses: {}, total: 0 }, 
              nonCurrent: { propertyPlantEquipment: {}, accumulatedDepreciation: 0, total: 0 }, 
              total: 0 
            },
            liabilities: {
              current: { accountsPayable: {}, accruedExpenses: {}, tenantDeposits: {}, taxesPayable: {}, total: 0 }, 
              nonCurrent: { longTermLoans: {}, otherLongTermLiabilities: {}, total: 0 }, 
              total: 0 
            },
            equity: {
              capital: { accountCode: '3000', accountName: 'Owner\'s Capital', amount: 0 }, 
              retainedEarnings: { accountCode: '3100', accountName: 'Retained Earnings', amount: 0 }, 
              otherEquity: { accountCode: '3200', accountName: 'Other Equity', amount: 0 }, 
              total: 0 
            },
            summary: {
              totalAssets: 0, 
              totalLiabilities: 0, 
              totalEquity: 0, 
              workingCapital: 0, 
              currentRatio: 0, 
              debtToEquity: 0 
            }
          };
          continue;
        }
        
        if (monthData) {
          // Use the pre-structured month data from the promise
          monthlyData[monthKey] = monthData;
          
          // Accumulate annual totals from the promise result
          if (annualTotals) {
            annualSummary.totalAnnualAssets += annualTotals.totalAssets || 0;
            annualSummary.totalAnnualLiabilities += annualTotals.totalLiabilities || 0;
            annualSummary.totalAnnualEquity += annualTotals.totalEquity || 0;
            annualSummary.totalAnnualCurrentAssets += annualTotals.totalCurrentAssets || 0;
            annualSummary.totalAnnualNonCurrentAssets += annualTotals.totalNonCurrentAssets || 0;
            annualSummary.totalAnnualCurrentLiabilities += annualTotals.totalCurrentLiabilities || 0;
            annualSummary.totalAnnualNonCurrentLiabilities += annualTotals.totalNonCurrentLiabilities || 0;
          }
        }
      }
      
      // Calculate annual averages (divide by 12 for monthly average)
      annualSummary.totalAnnualAssets = Math.round(annualSummary.totalAnnualAssets / 12);
      annualSummary.totalAnnualLiabilities = Math.round(annualSummary.totalAnnualLiabilities / 12);
      annualSummary.totalAnnualEquity = Math.round(annualSummary.totalAnnualEquity / 12);
      annualSummary.totalAnnualCurrentAssets = Math.round(annualSummary.totalAnnualCurrentAssets / 12);
      annualSummary.totalAnnualNonCurrentAssets = Math.round(annualSummary.totalAnnualNonCurrentAssets / 12);
      annualSummary.totalAnnualCurrentLiabilities = Math.round(annualSummary.totalAnnualCurrentLiabilities / 12);
      annualSummary.totalAnnualNonCurrentLiabilities = Math.round(annualSummary.totalAnnualNonCurrentLiabilities / 12);
      
      const result = {
        success: true,
        data: {
          year: year,
          residence: residence || 'all',
          monthly: monthlyData,
          annualSummary: annualSummary
        },
        message: `Monthly balance sheet generated for ${year}${residence ? ` for residence: ${residence}` : ' (all residences)'}`
      };
      
      console.log(`‚úÖ Monthly Balance Sheet generated successfully for ${year}`);
      return result;
      
    } catch (error) {
      console.error('‚ùå Error generating monthly balance sheet:', error);
      throw error;
    }
  }

  /**
   * Generate Monthly Activity Balance Sheet (shows monthly changes, not cumulative balances)
   * This method calculates the change in balances for a specific month
   */
  static async generateMonthlyActivityBalanceSheet(year, month, residence = null, cachedAccounts = null) {
    try {
      console.log(`üìä Generating Monthly Activity Balance Sheet for ${year}-${month}${residence ? ` for residence: ${residence}` : ' (all residences)'}`);
      
      const monthStartDate = new Date(year, month - 1, 1); // First day of the month
      const monthEndDate = new Date(year, month, 0); // Last day of the month
      const monthKey = `${year}-${String(month).padStart(2, '0')}`;
      
      // Get transactions that occurred ONLY in this specific month
      const monthQuery = {
        date: { 
          $gte: monthStartDate, 
          $lte: monthEndDate 
        },
        status: 'posted'
      };
      
      if (residence) {
        monthQuery.residence = residence;
      }
      
      // Get all transactions for this month with timeout optimization
      const monthTransactions = await TransactionEntry.find(monthQuery)
        .sort({ date: 1 })
        .maxTimeMS(15000); // 15 second timeout
      
      console.log(`üîç Found ${monthTransactions.length} transactions for ${monthKey}`);
      
      // üöÄ OPTIMIZATION: Early exit for months with no transactions
      if (monthTransactions.length === 0) {
        console.log(`‚ö° No transactions found for ${monthKey}, returning zero balance sheet`);
        return {
          asOfDate: monthEndDate,
          residence: residence || 'all',
          assets: { 
            current: {}, 
            nonCurrent: {}, 
            totalCurrent: 0, 
            totalNonCurrent: 0, 
            totalAssets: 0,
            accumulatedDepreciation: 0
          },
          liabilities: { 
            current: {}, 
            nonCurrent: {}, 
            totalCurrent: 0, 
            totalNonCurrent: 0, 
            totalLiabilities: 0 
          },
          equity: { 
            capital: 0, 
            retainedEarnings: 0, 
            otherEquity: 0,
            totalEquity: 0 
          },
          workingCapital: 0,
          currentRatio: 0,
          debtToEquity: 0,
          message: `No transactions found for ${monthKey} - zero balance sheet returned`
        };
      }
      
      // Initialize balance sheet structure for monthly activity
      const balanceSheet = {
        asOfDate: monthEndDate,
        residence: residence || 'all',
        assets: { 
          current: {}, 
          nonCurrent: {}, 
          totalCurrent: 0, 
          totalNonCurrent: 0, 
          totalAssets: 0,
          accumulatedDepreciation: 0
        },
        liabilities: { 
          current: {}, 
          nonCurrent: {}, 
          totalCurrent: 0, 
          totalNonCurrent: 0, 
          totalLiabilities: 0 
        },
        equity: { 
          capital: 0, 
          retainedEarnings: 0, 
          otherEquity: 0,
          totalEquity: 0 
        },
        workingCapital: 0,
        currentRatio: 0,
        debtToEquity: 0,
        message: 'Monthly activity balance sheet generated successfully'
      };
      
      // üöÄ OPTIMIZATION: Use cached accounts if provided, otherwise fetch once
      let allAccounts = cachedAccounts;
      if (!allAccounts) {
      const Account = require('../models/Account');
        allAccounts = await Account.find().sort({ code: 1 });
      }
      
      // Initialize account balances for monthly activity
      const accountBalances = {};
      
      // Initialize ALL accounts with zero balances first
      allAccounts.forEach(account => {
        accountBalances[account.code] = {
          code: account.code,
          name: account.name,
          type: account.type,
          debitTotal: 0,
          creditTotal: 0,
          balance: 0,
          description: account.description || '',
          category: account.category || 'Other'
        };
      });
      
      // üöÄ OPTIMIZATION: Process transactions more efficiently with batch processing
      console.log(`‚ö° Processing ${monthTransactions.length} transactions with optimized batch processing...`);
      
      // Group transactions by account code for more efficient processing
      const accountTransactionMap = new Map();
      
      monthTransactions.forEach(entry => {
        if (entry.entries && Array.isArray(entry.entries)) {
          entry.entries.forEach(lineItem => {
            const accountCode = lineItem.accountCode;
            const accountName = lineItem.accountName;
            const accountType = lineItem.accountType;
            const debit = lineItem.debit || 0;
            const credit = lineItem.credit || 0;
            
            if (!accountTransactionMap.has(accountCode)) {
              accountTransactionMap.set(accountCode, {
                code: accountCode,
                name: accountName || `Account ${accountCode}`,
                type: accountType || 'Asset',
                debitTotal: 0,
                creditTotal: 0,
                description: '',
                category: 'Other'
              });
            }
            
            const accountData = accountTransactionMap.get(accountCode);
            accountData.debitTotal += debit;
            accountData.creditTotal += credit;
            if (accountName) accountData.name = accountName;
            if (accountType) accountData.type = accountType;
          });
        }
      });
      
      // Apply the transaction data to account balances
      accountTransactionMap.forEach((transactionData, accountCode) => {
            if (accountBalances[accountCode]) {
          accountBalances[accountCode].debitTotal += transactionData.debitTotal;
          accountBalances[accountCode].creditTotal += transactionData.creditTotal;
              // Update name and type from transaction if more recent
          if (transactionData.name) accountBalances[accountCode].name = transactionData.name;
          if (transactionData.type) accountBalances[accountCode].type = transactionData.type;
            } else {
              // Create account if not found in database (fallback)
              accountBalances[accountCode] = {
                code: accountCode,
            name: transactionData.name,
            type: transactionData.type,
            debitTotal: transactionData.debitTotal,
            creditTotal: transactionData.creditTotal,
                balance: 0,
            description: transactionData.description,
            category: transactionData.category
              };
        }
      });
      
      // Calculate net balance for each account (monthly activity)
      Object.values(accountBalances).forEach(account => {
        switch (account.type) {
          case 'Asset':
            account.balance = account.debitTotal - account.creditTotal;
            break;
          case 'Liability':
            account.balance = account.creditTotal - account.debitTotal;
            break;
          case 'Equity':
            account.balance = account.creditTotal - account.debitTotal;
            break;
          case 'Income':
            // Income should be positive (credit > debit means income earned)
            account.balance = Math.max(0, account.creditTotal - account.debitTotal);
            break;
          case 'Expense':
            // Expense should be positive (debit > credit means expense incurred)
            account.balance = Math.max(0, account.debitTotal - account.creditTotal);
            break;
        }
      });
      
      // üöÄ OPTIMIZATION: Only process accounts with non-zero balances to improve performance
      console.log(`‚ö° Processing only accounts with non-zero balances for better performance...`);
      
      // Categorize into balance sheet sections
      Object.values(accountBalances).forEach(account => {
        const balance = account.balance;
        
        // Skip accounts with zero balance to improve performance
        if (balance === 0) {
          return;
        }
        
        // Use comprehensive category mapping to ensure all accounts are properly categorized
        const mappedCategory = this.mapAccountToCategory(account.code, account.name, account.type);
        
        switch (account.type) {
          case 'Asset':
            if (this.isCurrentAsset(account.code, account.name)) {
              balanceSheet.assets.current[account.code] = {
                name: account.name,
                balance: Math.max(0, balance),
                description: this.getAssetDescription(account.code, account.name),
                category: mappedCategory
              };
              balanceSheet.assets.totalCurrent += Math.max(0, balance);
            } else {
              balanceSheet.assets.nonCurrent[account.code] = {
                name: account.name,
                balance: Math.max(0, balance),
                description: this.getAssetDescription(account.code, account.name),
                category: mappedCategory
              };
              balanceSheet.assets.totalNonCurrent += Math.max(0, balance);
            }
            break;
            
          case 'Liability':
            if (this.isCurrentLiability(account.code, account.name)) {
              balanceSheet.liabilities.current[account.code] = {
                name: account.name,
                balance: Math.abs(balance), // Use absolute value for liabilities
                description: this.getLiabilityDescription(account.code, account.name),
                category: 'Current Liability'
              };
              balanceSheet.liabilities.totalCurrent += Math.abs(balance);
            } else {
              balanceSheet.liabilities.nonCurrent[account.code] = {
                name: account.name,
                balance: Math.abs(balance), // Use absolute value for liabilities
                description: this.getLiabilityDescription(account.code, account.name),
                category: 'Non-Current Liability'
              };
              balanceSheet.liabilities.totalNonCurrent += Math.abs(balance);
            }
            break;
            
          case 'Equity':
            if (account.code === '3000' || account.name.toLowerCase().includes('capital')) {
              balanceSheet.equity.capital = Math.abs(balance); // Use absolute value for capital
            } else if (account.name.toLowerCase().includes('retained') || account.name.toLowerCase().includes('earnings')) {
              balanceSheet.equity.retainedEarnings += Math.abs(balance); // Use absolute value for retained earnings
            } else {
              balanceSheet.equity.otherEquity += Math.abs(balance); // Use absolute value for other equity
            }
            break;
            
          case 'Income':
            // Income increases retained earnings
            balanceSheet.equity.retainedEarnings += balance;
            break;
            
          case 'Expense':
            // Expenses decrease retained earnings
            balanceSheet.equity.retainedEarnings -= balance;
            break;
        }
      });
      
      // AGGREGATE PARENT ACCOUNTS WITH CHILDREN (e.g., Account 2000 + child accounts)
      await this.aggregateParentChildAccounts(balanceSheet);
      
      // Calculate totals and ratios
      balanceSheet.assets.totalAssets = balanceSheet.assets.totalCurrent + balanceSheet.assets.totalNonCurrent;
      // Ensure liability totals are always positive
      balanceSheet.liabilities.totalLiabilities = Math.abs(balanceSheet.liabilities.totalCurrent + balanceSheet.liabilities.totalNonCurrent);
      // Ensure equity totals are always positive
      balanceSheet.equity.totalEquity = balanceSheet.equity.capital + balanceSheet.equity.retainedEarnings + balanceSheet.equity.otherEquity;
      
      // Calculate key ratios
      balanceSheet.workingCapital = balanceSheet.assets.totalCurrent - balanceSheet.liabilities.totalCurrent;
      balanceSheet.currentRatio = balanceSheet.liabilities.totalCurrent > 0 ? 
        balanceSheet.assets.totalCurrent / balanceSheet.liabilities.totalCurrent : 0;
      balanceSheet.debtToEquity = balanceSheet.equity.totalEquity > 0 ? 
        balanceSheet.liabilities.totalLiabilities / balanceSheet.equity.totalEquity : 0;
      
      console.log(`‚úÖ Monthly Activity Balance Sheet generated for ${monthKey}`);
      return balanceSheet;
      
    } catch (error) {
      console.error('‚ùå Error generating monthly activity balance sheet:', error);
      throw error;
    }
  }

  // Enhanced helper methods for formatting data
  static formatCashAndBankAccounts(currentAssets) {
    const cashAndBank = {};
    let total = 0;
    
    console.log('üîç formatCashAndBankAccounts - Processing current assets:', currentAssets);
    
    Object.entries(currentAssets).forEach(([code, asset]) => {
      // Include ALL cash, bank, and petty cash accounts by code pattern
      if (code.startsWith('100') || code.startsWith('101')) {
        console.log(`‚úÖ Including account in cashAndBank: ${code} - ${asset.name} = $${asset.balance}`);
        
        cashAndBank[code] = {
          accountCode: code,
          accountName: asset.name,
          amount: asset.balance,
          description: asset.description || this.getAssetDescription(code, asset.name),
          category: asset.category || 'Current Asset'
        };
        total += asset.balance;
      } else {
        console.log(`‚ùå Excluding account from cashAndBank: ${code} - ${asset.name} = $${asset.balance}`);
      }
    });
    
    cashAndBank.total = total;
    console.log(`üí∞ cashAndBank total: $${total}`);
    console.log(`üìã cashAndBank accounts:`, Object.keys(cashAndBank));
    
    return cashAndBank;
  }

  static formatAccountsReceivable(currentAssets) {
    const accountsReceivable = {};
    
    Object.entries(currentAssets).forEach(([code, asset]) => {
      // Look for any account that is an AR account (student-specific or generic)
      if (asset.name.toLowerCase().includes('receivable') || code.startsWith('1100')) {
        accountsReceivable[code] = {
          accountCode: code,
          accountName: asset.name,
          amount: asset.balance,
          description: asset.description,
          category: asset.category
        };
      }
    });
    
    // If no specific AR accounts found, create a default one
    if (Object.keys(accountsReceivable).length === 0) {
      accountsReceivable.default = {
        accountCode: '1100',
        accountName: 'Accounts Receivable - Tenants',
        amount: 0,
        description: 'Accounts receivable from tenants',
        category: 'Current Asset'
      };
    }
    
    return accountsReceivable;
  }

  static formatInventoryAccounts(currentAssets) {
    const inventory = {};
    
    Object.entries(currentAssets).forEach(([code, asset]) => {
      if (asset.name.toLowerCase().includes('inventory') || asset.name.toLowerCase().includes('supplies')) {
        inventory[code] = {
          accountCode: code,
          accountName: asset.name,
          amount: asset.balance,
          description: asset.description,
          category: asset.category
        };
      }
    });
    
    return inventory;
  }

  static formatPrepaidAccounts(currentAssets) {
    const prepaid = {};
    
    Object.entries(currentAssets).forEach(([code, asset]) => {
      if (asset.name.toLowerCase().includes('prepaid')) {
        prepaid[code] = {
          accountCode: code,
          accountName: asset.name,
          amount: asset.balance,
          description: asset.description,
          category: asset.category
        };
      }
    });
    
    return prepaid;
  }

  static formatFixedAssets(nonCurrentAssets) {
    const fixedAssets = {};
    
    Object.entries(nonCurrentAssets).forEach(([code, asset]) => {
      if (asset.name.toLowerCase().includes('property') || 
          asset.name.toLowerCase().includes('equipment') || 
          asset.name.toLowerCase().includes('building') ||
          asset.name.toLowerCase().includes('vehicle')) {
        fixedAssets[code] = {
          accountCode: code,
          accountName: asset.name,
          amount: asset.balance,
          description: asset.description,
          category: asset.category
        };
      }
    });
    
    return fixedAssets;
  }

  static formatAccountsPayable(currentLiabilities) {
    const accountsPayable = {};
    
    Object.entries(currentLiabilities).forEach(([code, liability]) => {
      if (liability.name.toLowerCase().includes('payable')) {
        accountsPayable[code] = {
          accountCode: code,
          accountName: liability.name,
          amount: Math.abs(liability.balance), // FIX: Ensure positive values for liabilities
          description: liability.description,
          category: liability.category
        };
      }
    });
    
    return accountsPayable;
  }

  static formatAccruedExpenses(currentLiabilities) {
    const accrued = {};
    
    Object.entries(currentLiabilities).forEach(([code, liability]) => {
      if (liability.name.toLowerCase().includes('accrued')) {
        accrued[code] = {
          accountCode: code,
          accountName: liability.name,
          amount: Math.abs(liability.balance), // FIX: Ensure positive values for liabilities
          description: liability.description,
          category: liability.category
        };
      }
    });
    
    return accrued;
  }

  static formatTenantDeposits(currentLiabilities) {
    const deposits = {};
    
    Object.entries(currentLiabilities).forEach(([code, liability]) => {
      if (liability.name.toLowerCase().includes('deposit') || 
          liability.name.toLowerCase().includes('deferred') ||
          liability.name.toLowerCase().includes('unearned')) {
        deposits[code] = {
          accountCode: code,
          accountName: liability.name,
          amount: Math.abs(liability.balance), // FIX: Ensure positive values for liabilities
          description: liability.description,
          category: liability.category
        };
      }
    });
    
    return deposits;
  }

  static formatTaxesPayable(currentLiabilities) {
    const taxes = {};
    
    Object.entries(currentLiabilities).forEach(([code, liability]) => {
      if (liability.name.toLowerCase().includes('tax')) {
        taxes[code] = {
          accountCode: code,
          accountName: liability.name,
          amount: Math.abs(liability.balance), // FIX: Ensure positive values for liabilities
          description: liability.description,
          category: liability.category
        };
      }
    });
    
    return taxes;
  }

  static formatDeferredIncome(currentLiabilities) {
    const deferredIncome = {};
    
    Object.entries(currentLiabilities).forEach(([code, liability]) => {
      if (liability.name.toLowerCase().includes('deferred') || 
          liability.name.toLowerCase().includes('unearned') ||
          code === '2030') { // Specifically include account 2030
        deferredIncome[code] = {
          accountCode: code,
          accountName: liability.name,
          amount: Math.abs(liability.balance),
          description: liability.description,
          category: liability.category
        };
      }
    });
    
    return deferredIncome;
  }

  static formatLongTermLoans(nonCurrentLiabilities) {
    const loans = {};
    
    Object.entries(nonCurrentLiabilities).forEach(([code, liability]) => {
      if (liability.name.toLowerCase().includes('loan')) {
        loans[code] = {
          accountCode: code,
          accountName: liability.name,
          amount: Math.abs(liability.balance), // FIX: Ensure positive values for liabilities
          description: liability.description,
          category: liability.category
        };
      }
    });
    
    return loans;
  }

  static formatOtherLongTermLiabilities(nonCurrentLiabilities) {
    const other = {};
    
    Object.entries(nonCurrentLiabilities).forEach(([code, liability]) => {
      if (!liability.name.toLowerCase().includes('loan')) {
        other[code] = {
          accountCode: code,
          accountName: liability.name,
          amount: Math.abs(liability.balance), // FIX: Ensure positive values for liabilities
          category: liability.category
        };
      }
    });
    
    return other;
  }
  
  // Enhanced helper methods for proper classification
  static isCurrentAsset(accountCode, accountName) {
    const currentAssetCodes = ['1000', '1010', '1011', '1012', '1013', '1014', '1100', '1200', '1300', '1400', '1500'];
    const currentAssetNames = ['cash', 'bank', 'petty', 'receivable', 'inventory', 'prepaid'];
    
    return currentAssetCodes.includes(accountCode) || 
           currentAssetNames.some(name => accountName.toLowerCase().includes(name));
  }
  
  // ‚úÖ NEW: Comprehensive account category mapping
  static mapAccountToCategory(accountCode, accountName, accountType) {
    // Map by account code pattern first (most reliable)
    if (accountCode.startsWith('100') || accountCode.startsWith('101')) {
      return 'Current Asset'; // Cash, Bank, Petty Cash
    } else if (accountCode.startsWith('110')) {
      return 'Current Asset'; // Accounts Receivable
    } else if (accountCode.startsWith('120')) {
      return 'Current Asset'; // Inventory
    } else if (accountCode.startsWith('130')) {
      return 'Current Asset'; // Prepaid Expenses
    } else if (accountCode.startsWith('200')) {
      return 'Current Liability'; // Accounts Payable, Deposits, etc.
    } else if (accountCode.startsWith('210')) {
      return 'Current Liability'; // Accrued Expenses
    } else if (accountCode.startsWith('300')) {
      return 'Equity'; // Capital, Retained Earnings
    } else if (accountCode.startsWith('400')) {
      return 'Income'; // Revenue accounts
    } else if (accountCode.startsWith('500')) {
      return 'Expense'; // Expense accounts
    }
    
    // Fallback to name-based mapping
    const nameLower = accountName.toLowerCase();
    if (nameLower.includes('cash') || nameLower.includes('bank') || nameLower.includes('petty')) {
      return 'Current Asset';
    } else if (nameLower.includes('receivable') || nameLower.includes('inventory') || nameLower.includes('prepaid')) {
      return 'Current Asset';
    } else if (nameLower.includes('payable') || nameLower.includes('deposit') || nameLower.includes('accrued')) {
      return 'Current Liability';
    } else if (nameLower.includes('capital') || nameLower.includes('equity') || nameLower.includes('earnings')) {
      return 'Equity';
    } else if (nameLower.includes('revenue') || nameLower.includes('income')) {
      return 'Income';
    } else if (nameLower.includes('expense') || nameLower.includes('cost')) {
      return 'Expense';
    }
    
    // Final fallback based on account type
    switch (accountType) {
      case 'Asset': return 'Current Asset';
      case 'Liability': return 'Current Liability';
      case 'Equity': return 'Equity';
      case 'Income': return 'Income';
      case 'Expense': return 'Expense';
      default: return 'Other';
    }
  }
  
  static isCurrentLiability(accountCode, accountName) {
    const currentLiabilityCodes = ['2000', '2010', '2020', '2030', '2040', '2100', '2200', '2300'];
    const currentLiabilityNames = ['payable', 'accrued', 'deposit', 'tax', 'deferred', 'unearned', 'short term'];
    
    return currentLiabilityCodes.includes(accountCode) || 
           currentLiabilityNames.some(name => accountName.toLowerCase().includes(name));
  }
  
  static getAssetDescription(accountCode, accountName) {
    if (accountCode === '1000' || accountName.toLowerCase().includes('cash')) {
      return 'Cash and cash equivalents';
    } else if (accountCode === '1010' || accountCode === '1011' || accountCode === '1012' || accountCode === '1013' || accountCode === '1014' || accountName.toLowerCase().includes('petty')) {
      return 'Petty cash funds for operational expenses';
    } else if (accountCode === '1100' || accountName.toLowerCase().includes('receivable')) {
      return 'Accounts receivable from tenants';
    } else if (accountCode === '1200' || accountName.toLowerCase().includes('inventory')) {
      return 'Inventory and supplies';
    } else if (accountCode === '1300' || accountName.toLowerCase().includes('prepaid')) {
      return 'Prepaid expenses';
    } else if (accountCode === '3000' || accountName.toLowerCase().includes('property')) {
      return 'Property and buildings';
    } else if (accountCode === '3100' || accountName.toLowerCase().includes('equipment')) {
      return 'Equipment and furniture';
    } else if (accountCode === '3200' || accountName.toLowerCase().includes('vehicle')) {
      return 'Vehicles and transportation';
    } else {
      return 'Other assets';
    }
  }
  
  static getLiabilityDescription(accountCode, accountName) {
    if (accountCode === '2000' || accountName.toLowerCase().includes('payable')) {
      return 'Accounts payable to suppliers';
    } else if (accountCode === '2100' || accountName.toLowerCase().includes('accrued')) {
      return 'Accrued expenses and liabilities';
    } else if (accountCode === '2200' || accountName.toLowerCase().includes('deposit')) {
      return 'Tenant security deposits';
    } else if (accountCode === '2300' || accountName.toLowerCase().includes('tax')) {
      return 'Taxes payable';
    } else if (accountCode === '2400' || accountName.toLowerCase().includes('loan')) {
      return 'Long-term loans and borrowings';
    } else {
      return 'Other liabilities';
    }
  }

  /**
   * Aggregate parent accounts with their child accounts (e.g., Account 2000 + children)
   */
  static async aggregateParentChildAccounts(balanceSheet) {
    try {
      console.log('\nüîó Aggregating parent-child accounts...');
      
      // Get the main Accounts Payable account (2000)
      const Account = require('../models/Account');
      const mainAPAccount = await Account.findOne({ code: '2000' });
      
      if (!mainAPAccount) {
        console.log('‚ö†Ô∏è Main Accounts Payable account (2000) not found');
        return;
      }

      // Get all accounts payable accounts (both children of 2000 and standalone AP accounts)
      const childAccounts = await Account.find({ 
        parentAccount: mainAPAccount._id,
        isActive: true
      });

      // Also get standalone accounts payable accounts that aren't children of 2000
      const standaloneAPAccounts = await Account.find({
        type: 'Liability',
        isActive: true,
        $or: [
          { name: { $regex: /accounts payable/i } },
          { code: { $regex: '^21' } } // Include 2100, 2101, 2102, etc.
        ],
        parentAccount: { $ne: mainAPAccount._id }
      });

      // Combine all accounts payable accounts
      const allAPAccounts = [...childAccounts, ...standaloneAPAccounts];

      console.log(`üìä Found ${childAccounts.length} child accounts for account 2000`);
      console.log(`üìä Found ${standaloneAPAccounts.length} standalone AP accounts`);
      console.log(`üìä Found ${allAPAccounts.length} total AP accounts`);
      
      // Calculate total balance for account 2000 including all AP accounts
      let totalAPBalance = 0;
      
      // Add main account 2000 balance
      if (balanceSheet.liabilities.current['2000']) {
        totalAPBalance += balanceSheet.liabilities.current['2000'].balance;
        console.log(`   Main account 2000: $${balanceSheet.liabilities.current['2000'].balance}`);
      }
      
      // Add all AP account balances (including children and orphaned accounts)
      for (const apAccount of allAPAccounts) {
        // Skip the main account 2000 as we already added it above
        if (apAccount.code === '2000') {
          continue;
        }
        
        if (balanceSheet.liabilities.current[apAccount.code]) {
          const accountBalance = balanceSheet.liabilities.current[apAccount.code].balance;
          totalAPBalance += accountBalance;
          const isChild = apAccount.parentAccount && apAccount.parentAccount.toString() === mainAPAccount._id.toString();
          const status = isChild ? 'CHILD' : 'ORPHANED';
          console.log(`   ${status} account ${apAccount.code}: $${accountBalance}`);
        }
      }
      
      console.log(`   Total aggregated balance: $${totalAPBalance}`);
      
      // Update the main account 2000 with the aggregated total
      if (balanceSheet.liabilities.current['2000']) {
        balanceSheet.liabilities.current['2000'].balance = totalAPBalance;
        balanceSheet.liabilities.current['2000'].aggregated = true;
        balanceSheet.liabilities.current['2000'].childAccounts = childAccounts.map(c => c.code);
        balanceSheet.liabilities.current['2000'].totalWithChildren = totalAPBalance;
        
        console.log(`‚úÖ Updated account 2000 with aggregated balance: $${totalAPBalance}`);
      }
      
      // Recalculate total current liabilities
      balanceSheet.liabilities.totalCurrent = Object.values(balanceSheet.liabilities.current)
        .reduce((total, liability) => total + liability.balance, 0);
      
      console.log(`‚úÖ Recalculated total current liabilities: $${balanceSheet.liabilities.totalCurrent}`);
      
    } catch (error) {
      console.error('‚ùå Error aggregating parent-child accounts:', error);
      // Don't throw error as this is not critical for balance sheet generation
    }
  }
}

module.exports = BalanceSheetService;



















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































