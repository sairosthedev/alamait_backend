const mongoose = require('mongoose');
const TransactionEntry = require('../models/TransactionEntry');

// Ensure we're using the correct Atlas database connection
const MONGODB_URI = process.env.MONGODB_URI || 'mongodb+srv://macdonaldsairos24:macdonald24@cluster0.ulvve.mongodb.net/test?retryWrites=true&w=majority&appName=Cluster0';

class BalanceSheetService {
  /**
   * Generate Balance Sheet for Accrual Basis
   * Assets = Cash + AR + Property + Equipment + Prepaid
   * Liabilities = AP + Loans + Deposits + Accrued Expenses + Taxes
   * Equity = Capital + Retained Earnings (from Income Statement)
   */
  static async generateBalanceSheet(asOfDate, residence = null) {
    try {
      console.log(`ðŸ“Š Generating Balance Sheet as of ${asOfDate}`);
      
      // Ensure we're connected to the correct Atlas database
      if (mongoose.connection.readyState !== 1) {
        console.log('ðŸ”Œ Connecting to Atlas database...');
        await mongoose.connect(MONGODB_URI, {
          useNewUrlParser: true,
          useUnifiedTopology: true,
        });
      }
      console.log(`ðŸ—„ï¸ Using database: ${mongoose.connection.db.databaseName}`);
      
      // Use all transactions up to asOfDate (balance sheet should include all historical transactions)
      const asOf = new Date(asOfDate);
      const asOfMonth = asOf.getMonth() + 1;
      const asOfYear = asOf.getFullYear();
      
      // For monthly balance sheets, filter by month to exclude cross-month timezone issues
      const isMonthlyBalanceSheet = asOfDate.toString().includes('31');
      console.log(`ðŸ“… Month-end balance sheet detected: ${isMonthlyBalanceSheet}`);
      const monthKey = `${asOfYear}-${String(asOfMonth).padStart(2, '0')}`;
      
      // For balance sheet, we need to include:
      // 1. All accruals up to asOf date (rental_accrual, expense_accrual - these create the obligations)
      // 2. All payments up to asOf date (payment, vendor_payment - these settle the obligations)
      // 3. All other transactions up to asOf date (non-payment transactions)
      
      // For balance sheets, always use cumulative filtering (all transactions up to as-of date)
      // Balance sheets should show cumulative balances, not just monthly transactions
      let dateFilter = { $lte: asOf };
      console.log(`ðŸ“… Using cumulative filter: up to ${asOf.toISOString()}`);
      
      // Note: Removed strict monthly filtering as it was causing balance sheet discrepancies
      // Balance sheets must include all historical transactions to show accurate cumulative balances
      
      const accrualQuery = {
        source: { $in: ['rental_accrual', 'expense_accrual'] },
        date: dateFilter,
        status: 'posted',
        voided: { $ne: true } // Exclude voided transactions
      };
      
      const paymentQuery = {
        source: { $in: ['payment', 'vendor_payment', 'expense_payment'] },
        date: dateFilter,
        status: 'posted',
        voided: { $ne: true } // Exclude voided transactions
      };
      
      const otherQuery = {
        source: { $nin: ['rental_accrual', 'expense_accrual', 'payment', 'vendor_payment', 'expense_payment'] },
        date: dateFilter,
        status: 'posted',
        voided: { $ne: true } // Exclude voided transactions
      };
      
      // Include manual transactions in the "other" category
      // This includes negotiated payments, refunds, and other manual adjustments
      const manualQuery = {
        source: { $in: ['manual', 'other_income', 'refund', 'negotiated_payment'] },
        date: dateFilter,
        status: 'posted',
        voided: { $ne: true } // Exclude voided transactions
      };
      
      if (residence) {
        accrualQuery.residence = residence;
        paymentQuery.residence = residence;
        otherQuery.residence = residence;
        manualQuery.residence = residence;
      }
      
      // Get all relevant transactions with timeout optimization
      const [accrualEntries, paymentEntries, otherEntries, manualEntries] = await Promise.all([
        TransactionEntry.find(accrualQuery).sort({ date: 1 }).maxTimeMS(20000), // 20 second timeout
        TransactionEntry.find(paymentQuery).sort({ date: 1 }).maxTimeMS(20000), // 20 second timeout
        TransactionEntry.find(otherQuery).sort({ date: 1 }).maxTimeMS(20000), // 20 second timeout
        TransactionEntry.find(manualQuery).sort({ date: 1 }).maxTimeMS(20000) // 20 second timeout
      ]);
      
      console.log(`ðŸ” Found ${accrualEntries.length} accrual entries, ${paymentEntries.length} payment entries, ${otherEntries.length} other entries, ${manualEntries.length} manual entries`);
      
      // Check for specific negotiated payment transaction
      const negotiatedPayment = manualEntries.find(tx => tx.transactionId === 'NEG-1757465405612');
      if (negotiatedPayment) {
        console.log(`âœ… Found negotiated payment transaction: ${negotiatedPayment.description}`);
        console.log(`   Date: ${negotiatedPayment.date}`);
        console.log(`   Status: ${negotiatedPayment.status}`);
        negotiatedPayment.entries.forEach((entry, index) => {
          console.log(`   Entry ${index + 1}: ${entry.accountCode} - ${entry.accountName} (${entry.accountType})`);
          console.log(`     Debit: $${entry.debit}, Credit: $${entry.credit}`);
          console.log(`     Balance Impact: $${entry.credit - entry.debit}`);
        });
        console.log(`ðŸ” This transaction should reduce AR by $1.84 and reduce income by $1.84`);
      } else {
        console.log(`âŒ Negotiated payment transaction NEG-1757465405612 not found in manual entries`);
      }
      
      const allEntries = [...accrualEntries, ...paymentEntries, ...otherEntries, ...manualEntries];
      
      // Initialize balance sheet with proper structure
      const balanceSheet = {
        asOfDate: new Date(asOfDate),
        residence: residence || 'all',
        assets: { 
          current: {}, 
          nonCurrent: {}, 
          totalCurrent: 0, 
          totalNonCurrent: 0, 
          totalAssets: 0,
          accumulatedDepreciation: 0
        },
        liabilities: { 
          current: {}, 
          nonCurrent: {}, 
          totalCurrent: 0, 
          totalNonCurrent: 0, 
          totalLiabilities: 0 
        },
        equity: { 
          capital: 0, 
          retainedEarnings: 0, 
          otherEquity: 0,
          totalEquity: 0 
        },
        workingCapital: 0,
        currentRatio: 0,
        debtToEquity: 0,
        message: 'Balance sheet generated successfully'
      };
      
      // Get ALL accounts from the database to ensure none are missing
      const Account = require('../models/Account');
      const allAccounts = await Account.find().sort({ code: 1 });
      
      console.log(`ðŸ” Found ${allEntries.length} transaction entries and ${allAccounts.length} accounts in database`);
      
      // Debug: Show all accounts found
      console.log('ðŸ“‹ All accounts from database:', allAccounts.map(acc => ({ code: acc.code, name: acc.name, type: acc.type })));
      
      // Process entries to build account balances
      const accountBalances = {};
      
      // Initialize ALL accounts with zero balances first
      allAccounts.forEach(account => {
        accountBalances[account.code] = {
          code: account.code,
          name: account.name,
          type: account.type,
          debitTotal: 0,
          creditTotal: 0,
          balance: 0,
          description: account.description || '',
          category: account.category || 'Other'
        };
      });
      
      console.log(`ðŸ” Initialized ${Object.keys(accountBalances).length} accounts from database`);
      
      // Process transaction entries to update balances
      allEntries.forEach(entry => {
        if (entry.entries && Array.isArray(entry.entries)) {
          entry.entries.forEach(lineItem => {
            const accountCode = lineItem.accountCode;
            const accountName = lineItem.accountName;
            const accountType = lineItem.accountType;
            const debit = lineItem.debit || 0;
            const credit = lineItem.credit || 0;
            
            // Debug: Log AR transactions to see credits being processed
            if (accountCode && accountCode.startsWith('1100')) {
              console.log(`ðŸ” Processing AR transaction: ${entry.transactionId} - ${accountCode} - Debit: $${debit}, Credit: $${credit}`);
            }
            
            if (accountBalances[accountCode]) {
              accountBalances[accountCode].debitTotal += debit;
              accountBalances[accountCode].creditTotal += credit;
              // Update name and type from transaction if more recent
              if (accountName) accountBalances[accountCode].name = accountName;
              if (accountType) accountBalances[accountCode].type = accountType;
            } else {
              // Create account if not found in database (fallback)
              accountBalances[accountCode] = {
                code: accountCode,
                name: accountName || `Account ${accountCode}`,
                type: accountType || 'Asset',
                debitTotal: debit,
                creditTotal: credit,
                balance: 0,
                description: '',
                category: 'Other'
              };
            }
          });
        }
      });
      
      console.log(`ðŸ” Account balances after processing transactions:`, Object.keys(accountBalances).length);
      
      // ðŸ†• FIX: Calculate monthSettled-based balances from the already filtered transactions
      try {
        // Calculate AR balance from the filtered transactions
        let arDebits = 0;
        let arCredits = 0;
        let cashByMonth = 0;
        let depositsTotal = 0;
        let deferredTotal = 0;
        
        // Process accrual entries (AR debits, deposits)
        accrualEntries.forEach(tx => {
          tx.entries.forEach(line => {
            if (line.accountCode && (line.accountCode.startsWith('1100-') || line.accountCode === '1100')) {
              arDebits += Number(line.debit || 0);
            } else if (line.accountCode && line.accountCode.startsWith('2020')) {
              // Deposit accounts (created in accrual entries like lease start)
              depositsTotal += (line.credit || 0) - (line.debit || 0);
            } else if (line.accountCode && line.accountCode.startsWith('2200')) {
              // Deferred income accounts
              deferredTotal += (line.credit || 0) - (line.debit || 0);
            }
          });
        });
        
        // Process payment entries (AR credits, cash, deposits, deferred)
        paymentEntries.forEach(tx => {
          tx.entries.forEach(line => {
            if (line.accountCode && (line.accountCode.startsWith('1100-') || line.accountCode === '1100')) {
              arCredits += Number(line.credit || 0);
            } else if (line.accountCode && (line.accountCode.match(/^100[0-9]/) || line.accountCode === '1000')) {
              // ðŸ†• FIX: REMOVED monthSettled filtering - include ALL cash transactions
              // This ensures ALL cash transactions are included in the balance sheet
              cashByMonth += Number(line.debit || 0) - Number(line.credit || 0);
              console.log(`ðŸ’° Cash transaction INCLUDED: ${tx.transactionId} - ${line.accountCode} - Debit: $${line.debit}, Credit: $${line.credit} - Source: ${tx.source} - Date: ${tx.date}`);
            } else if (line.accountCode && line.accountCode.startsWith('2020')) {
              // Deposit accounts
              depositsTotal += (line.credit || 0) - (line.debit || 0);
            } else if (line.accountCode && line.accountCode.startsWith('2200')) {
              // Deferred income accounts
              deferredTotal += (line.credit || 0) - (line.debit || 0);
            }
          });
        });
        
        // ðŸ†• FIX: Process manual entries (like negotiated payments) for A/R adjustments
        manualEntries.forEach(tx => {
          console.log(`ðŸ” Processing manual transaction: ${tx.transactionId} - ${tx.description}`);
          tx.entries.forEach(line => {
            if (line.accountCode && (line.accountCode.startsWith('1100-') || line.accountCode === '1100')) {
              // Manual transactions affect A/R (like negotiated payment discounts)
              arDebits += Number(line.debit || 0);
              arCredits += Number(line.credit || 0);
              console.log(`  ðŸ“ A/R Entry: ${line.accountCode} - Debit: $${line.debit}, Credit: $${line.credit}`);
              console.log(`  ðŸ“Š Running AR totals: Debits=$${arDebits}, Credits=$${arCredits}, Net=$${arDebits - arCredits}`);
            }
          });
        });
        
        // ðŸ†• FIX: Process other entries for A/R adjustments
        otherEntries.forEach(tx => {
          tx.entries.forEach(line => {
            if (line.accountCode && (line.accountCode.startsWith('1100-') || line.accountCode === '1100')) {
              // Other transactions affect A/R
              arDebits += Number(line.debit || 0);
              arCredits += Number(line.credit || 0);
            }
          });
        });
        
        const arByMonthOutstanding = arDebits - arCredits;
        
        console.log(`ðŸ“Š Final AR Calculation Summary:`);
        console.log(`   Total AR Debits: $${arDebits}`);
        console.log(`   Total AR Credits: $${arCredits}`);
        console.log(`   Net AR Outstanding: $${arByMonthOutstanding}`);
        
        // Override account balances with monthSettled values
        Object.values(accountBalances).forEach(account => {
          if (account.code && account.code.startsWith('1100-')) {
            // Keep individual AR account balances - don't override with aggregated total
            // This preserves individual transaction effects (like negotiated discounts)
            console.log(`ðŸ” Preserving individual AR account ${account.code} balance: $${account.balance}`);
          } else if (account.code === '1100') {
            // Calculate total AR balance from all individual student AR accounts
            let totalARBalance = 0;
            Object.values(accountBalances).forEach(arAccount => {
              if (arAccount.code && arAccount.code.startsWith('1100-') && arAccount.code !== '1100') {
                totalARBalance += arAccount.balance;
                console.log(`ðŸ” Preserving individual AR account ${arAccount.code} balance: $${arAccount.balance}`);
              }
            });
            
            // Set parent AR account to the aggregated total
            account.balance = totalARBalance;
            account.debitTotal = totalARBalance;
            account.creditTotal = 0;
            console.log(`ðŸ“Š Parent AR account 1100 aggregated from individual accounts: $${totalARBalance}`);
          } else if (account.code && account.code.match(/^100[0-9]/)) {
            // ðŸ†• FIX: DO NOT override cash balance - use the actual calculated balance from all transactions
            console.log(`ðŸ’° Cash account ${account.code} balance: $${account.balance} (from all transactions)`);
            // Don't override - keep the actual balance calculated from ALL transactions
            // account.balance = cashByMonth; // REMOVED THIS LINE
            // account.debitTotal = cashByMonth; // REMOVED THIS LINE
            // account.creditTotal = 0; // REMOVED THIS LINE
          } else if (account.code && account.code.startsWith('2020')) {
            // Override deposit accounts with monthSettled calculation
            account.balance = depositsTotal;
            account.debitTotal = 0;
            account.creditTotal = depositsTotal;
          } else if (account.code && account.code.startsWith('2200')) {
            // Override deferred income accounts with monthSettled calculation
            account.balance = deferredTotal;
            account.debitTotal = 0;
            account.creditTotal = deferredTotal;
          }
        });
        
        console.log(`ðŸ†• MonthSettled reclassification for ${monthKey}: AR=${arByMonthOutstanding}, Cash=${cashByMonth}, Deposits=${depositsTotal}, Deferred=${deferredTotal}`);
      } catch (error) {
        console.error('Error reclassifying by monthSettled:', error.message);
      }
      
      // Calculate net balance for each account
      Object.values(accountBalances).forEach(account => {
        switch (account.type) {
          case 'Asset':
            account.balance = account.debitTotal - account.creditTotal;
            // Debug: Log AR account balances to see credits being applied
            if (account.code && account.code.startsWith('1100')) {
              console.log(`ðŸ” AR Account ${account.code} (${account.name}): Debits=$${account.debitTotal}, Credits=$${account.creditTotal}, Balance=$${account.balance}`);
            }
            break;
          case 'Liability':
            account.balance = account.creditTotal - account.debitTotal;
            break;
          case 'Equity':
            account.balance = account.creditTotal - account.debitTotal;
            break;
          case 'Income':
            // Income should be positive (credit > debit means income earned)
            account.balance = account.creditTotal - account.debitTotal;
            break;
          case 'Expense':
            // Expense should be positive (debit > credit means expense incurred)
            account.balance = Math.max(0, account.debitTotal - account.creditTotal);
            break;
        }
      });
      
      // Categorize into balance sheet sections with proper classification
      Object.values(accountBalances).forEach(account => {
        const balance = account.balance;
        
        // Use comprehensive category mapping to ensure all accounts are properly categorized
        const mappedCategory = this.mapAccountToCategory(account.code, account.name, account.type);
        console.log(`ðŸ” Account ${account.code} (${account.name}): type=${account.type}, mapped=${mappedCategory}, balance=$${balance}`);
        
        switch (account.type) {
          case 'Asset':
            // Skip individual AR accounts (1100-*) as they are aggregated under parent AR account (1100)
            if (account.code && account.code.startsWith('1100-')) {
              console.log(`â­ï¸ Skipping individual AR account ${account.code} - aggregated under parent AR account 1100`);
              break;
            }
            
            if (this.isCurrentAsset(account.code, account.name)) {
              // For AR accounts, allow negative balances to represent legitimate reductions (like negotiated discounts)
              const assetBalance = account.code.startsWith('1100') ? balance : Math.max(0, balance);
              balanceSheet.assets.current[account.code] = {
                name: account.name,
                balance: assetBalance,
                description: this.getAssetDescription(account.code, account.name),
                category: mappedCategory
              };
              balanceSheet.assets.totalCurrent += assetBalance;
              console.log(`âœ… Added to current assets: ${account.code} - ${account.name} = $${assetBalance}`);
            } else {
              balanceSheet.assets.nonCurrent[account.code] = {
                name: account.name,
                balance: Math.max(0, balance),
                description: this.getAssetDescription(account.code, account.name),
                category: mappedCategory
              };
              balanceSheet.assets.totalNonCurrent += Math.max(0, balance);
              console.log(`âœ… Added to non-current assets: ${account.code} - ${account.name} = $${Math.max(0, balance)}`);
            }
            break;
            
          case 'Liability':
            if (this.isCurrentLiability(account.code, account.name)) {
              balanceSheet.liabilities.current[account.code] = {
                name: account.name,
                balance: Math.abs(balance), // Use absolute value for liabilities
                description: this.getLiabilityDescription(account.code, account.name),
                category: 'Current Liability'
              };
              balanceSheet.liabilities.totalCurrent += Math.abs(balance);
            } else {
              balanceSheet.liabilities.nonCurrent[account.code] = {
                name: account.name,
                balance: Math.abs(balance), // Use absolute value for liabilities
                description: this.getLiabilityDescription(account.code, account.name),
                category: 'Non-Current Liability'
              };
              balanceSheet.liabilities.totalNonCurrent += Math.abs(balance);
            }
            break;
            
          case 'Equity':
            if (account.code === '3000' || account.name.toLowerCase().includes('retained') || account.name.toLowerCase().includes('earnings')) {
              balanceSheet.equity.retainedEarnings += Math.abs(balance); // Use absolute value for retained earnings
            } else if (account.name.toLowerCase().includes('capital')) {
              balanceSheet.equity.capital = Math.abs(balance); // Use absolute value for capital
            } else {
              balanceSheet.equity.otherEquity += Math.abs(balance); // Use absolute value for other equity
            }
            break;
            
          case 'Income':
            // Retained Earnings = Total Income for the Month - Debits/Refunds/Discounts
            // For August: Rental Income $133.00 + Admin Fees $20.00 = $153.00
            balanceSheet.equity.retainedEarnings += balance;
            console.log(`ðŸ“ˆ Income account ${account.code} (${account.name}): +$${balance.toLocaleString()} â†’ Retained Earnings: $${balanceSheet.equity.retainedEarnings.toLocaleString()}`);
            console.log(`   Account details: Credits=$${account.creditTotal}, Debits=$${account.debitTotal}, Net=$${balance}`);
            break;
            
          case 'Expense':
            // Expenses decrease retained earnings
            balanceSheet.equity.retainedEarnings -= balance;
            console.log(`ðŸ“‰ Expense account ${account.code} (${account.name}): -$${balance.toLocaleString()} â†’ Retained Earnings: $${balanceSheet.equity.retainedEarnings.toLocaleString()}`);
            break;
        }
      });
      
      // AGGREGATE PARENT ACCOUNTS WITH CHILDREN (e.g., Account 2000 + child accounts)
      await this.aggregateParentChildAccounts(balanceSheet);
      
      // Debug: Show all accounts that were processed
      console.log('\nðŸ“Š BALANCE SHEET SUMMARY:');
      console.log('Current Assets:', Object.keys(balanceSheet.assets.current));
      console.log('Non-Current Assets:', Object.keys(balanceSheet.assets.nonCurrent));
      console.log('Current Liabilities:', Object.keys(balanceSheet.liabilities.current));
      console.log('Non-Current Liabilities:', Object.keys(balanceSheet.liabilities.nonCurrent));
      console.log('Equity:', Object.keys(balanceSheet.equity));
      
      // Debug: Show specific account processing for petty cash
      console.log('\nðŸ” PETTY CASH DEBUG:');
      const pettyCashAccounts = Object.values(accountBalances).filter(acc => 
        acc.code.startsWith('101') || acc.name.toLowerCase().includes('petty')
      );
      console.log('Petty cash accounts found:', pettyCashAccounts.map(acc => ({
        code: acc.code,
        name: acc.name,
        type: acc.type,
        balance: acc.balance,
        isCurrentAsset: this.isCurrentAsset(acc.code, acc.name)
      })));
      
      if (pettyCashAccounts.length === 0) {
        console.log('âŒ NO PETTY CASH ACCOUNTS FOUND!');
      }
      
      // Calculate totals and ratios
      balanceSheet.assets.totalAssets = balanceSheet.assets.totalCurrent + balanceSheet.assets.totalNonCurrent;
      // Ensure liability totals are always positive
      balanceSheet.liabilities.totalLiabilities = Math.abs(balanceSheet.liabilities.totalCurrent + balanceSheet.liabilities.totalNonCurrent);
      // Ensure equity totals are always positive
      balanceSheet.equity.totalEquity = balanceSheet.equity.capital + balanceSheet.equity.retainedEarnings + balanceSheet.equity.otherEquity;
      
      // Calculate key ratios
      balanceSheet.workingCapital = balanceSheet.assets.totalCurrent - balanceSheet.liabilities.totalCurrent;
      balanceSheet.currentRatio = balanceSheet.liabilities.totalCurrent > 0 ? 
        balanceSheet.assets.totalCurrent / balanceSheet.liabilities.totalCurrent : 0;
      balanceSheet.debtToEquity = balanceSheet.equity.totalEquity > 0 ? 
        balanceSheet.liabilities.totalLiabilities / balanceSheet.equity.totalEquity : 0;
      
      // Validate accounting equation: Assets = Liabilities + Equity
      const accountingEquation = Math.abs(
        balanceSheet.assets.totalAssets - 
        (balanceSheet.liabilities.totalLiabilities + balanceSheet.equity.totalEquity)
      );
      
      if (accountingEquation > 0.01) {
        console.warn(`âš ï¸ Accounting equation imbalance: ${accountingEquation}`);
        
        // Calculate what equity should be based on Assets - Liabilities
        const calculatedEquity = balanceSheet.assets.totalAssets - balanceSheet.liabilities.totalLiabilities;
        const equityDifference = calculatedEquity - balanceSheet.equity.totalEquity;
        
        console.log(`ðŸ” Accounting Equation Analysis:`);
        console.log(`  - Assets: $${balanceSheet.assets.totalAssets.toLocaleString()}`);
        console.log(`  - Liabilities: $${balanceSheet.liabilities.totalLiabilities.toLocaleString()}`);
        console.log(`  - Calculated Equity (Assets - Liabilities): $${calculatedEquity.toLocaleString()}`);
        console.log(`  - Actual Equity from Transactions: $${balanceSheet.equity.totalEquity.toLocaleString()}`);
        console.log(`  - Difference: $${equityDifference.toLocaleString()}`);
        
        // DO NOT auto-correct retained earnings - let it show the actual transaction-based value
        // This difference indicates either:
        // 1. Missing transactions
        // 2. Data entry errors
        // 3. Or legitimate accounting differences that need investigation
        
        balanceSheet.accountingEquation = {
          balanced: false,
          difference: accountingEquation,
          message: `Assets â‰  Liabilities + Equity - Difference: $${equityDifference.toLocaleString()}. Retained Earnings show actual transaction values.`,
          autoCorrected: false,
          correctionAmount: 0,
          investigationRequired: true
        };
      } else {
        balanceSheet.accountingEquation = {
          balanced: true,
          difference: 0,
          message: 'Assets = Liabilities + Equity âœ“'
        };
      }
      
      return balanceSheet;
      
    } catch (error) {
      console.error('âŒ Error generating balance sheet:', error);
      throw error;
    }
  }

  /**
   * Generate Monthly Balance Sheet for React Component
   * This method provides the data structure expected by the React component
   */
  static async generateMonthlyBalanceSheet(year, residence = null, type = 'monthly') {
    try {
      console.log(`ðŸ“Š Generating Monthly Balance Sheet for ${year}${residence ? ` for residence: ${residence}` : ' (all residences)'} - Type: ${type}`);
      
      const monthlyData = {};
      const annualSummary = {
        totalAnnualAssets: 0,
        totalAnnualLiabilities: 0,
        totalAnnualEquity: 0,
        totalAnnualCurrentAssets: 0,
        totalAnnualNonCurrentAssets: 0,
        totalAnnualCurrentLiabilities: 0,
        totalAnnualNonCurrentLiabilities: 0,
        // Enhanced: Add negotiation tracking
        totalNegotiations: 0,
        totalDiscountsGiven: 0,
        studentsAffected: new Set()
      };
      
      // ðŸš€ OPTIMIZATION: Cache accounts once to avoid repeated database queries
      console.log(`âš¡ Caching accounts to avoid repeated database queries... [DEPLOYED]`);
      const Account = require('../models/Account');
      
      // Set longer timeout for account fetching
      const cachedAccounts = await Account.find()
        .sort({ code: 1 })
        .maxTimeMS(30000); // 30 second timeout
      console.log(`ðŸ“‹ Cached ${cachedAccounts.length} accounts for reuse across all months`);
      
      // ðŸš€ OPTIMIZATION: Pre-filter accounts to only include balance sheet relevant ones
      const balanceSheetAccounts = cachedAccounts.filter(account => 
        ['Asset', 'Liability', 'Equity'].includes(account.type)
      );
      console.log(`ðŸ“Š Filtered to ${balanceSheetAccounts.length} balance sheet relevant accounts`);
      
      // ðŸš€ OPTIMIZATION: Process months sequentially to avoid database overload
      console.log(`âš¡ Processing months sequentially to prevent database timeout... [DEPLOYED]`);
      
      for (let month = 1; month <= 12; month++) {
        const monthEndDate = new Date(year, month, 0, 23, 59, 59, 999); // Last day of the month with end of day time
        const monthKey = month;
        
        try {
          console.log(`ðŸ“… Processing month ${month}/${year}...`);
          let monthBalanceSheet;
          
          // Always use cumulative balance calculation to include all transactions up to month end
          // This ensures negotiated payments and other adjustments are properly included
          monthBalanceSheet = await this.generateBalanceSheet(monthEndDate, residence);
          
          // Enhanced: Get negotiation details for this month
          const negotiationDetails = await this.getNegotiationDetailsForMonth(monthEndDate, residence);
          
          // Structure the data as expected by the React component with enhanced structure
          monthlyData[monthKey] = {
            month: monthKey,
            monthName: monthEndDate.toLocaleDateString('en-US', { month: 'long' }),
            assets: {
              current: {
                cashAndBank: this.formatCashAndBankAccounts(monthBalanceSheet.assets.current),
                accountsReceivable: this.formatAccountsReceivableWithNegotiations(monthBalanceSheet.assets.current, negotiationDetails),
                inventory: this.formatInventoryAccounts(monthBalanceSheet.assets.current),
                prepaidExpenses: this.formatPrepaidAccounts(monthBalanceSheet.assets.current),
                total: monthBalanceSheet.assets.totalCurrent
              },
              nonCurrent: {
                propertyPlantEquipment: this.formatFixedAssets(monthBalanceSheet.assets.nonCurrent),
                accumulatedDepreciation: monthBalanceSheet.assets.accumulatedDepreciation,
                total: monthBalanceSheet.assets.totalNonCurrent
              },
              total: monthBalanceSheet.assets.totalAssets
            },
            
            // Debug: Show what's in cashAndBank after formatting (move logs outside object construction)
            liabilities: {
              current: {
                accountsPayable: this.formatAccountsPayable(monthBalanceSheet.liabilities.current),
                accruedExpenses: this.formatAccruedExpenses(monthBalanceSheet.liabilities.current),
                tenantDeposits: this.formatTenantDeposits(monthBalanceSheet.liabilities.current),
                deferredIncome: this.formatDeferredIncome(monthBalanceSheet.liabilities.current),
                taxesPayable: this.formatTaxesPayable(monthBalanceSheet.liabilities.current),
                total: Math.abs(monthBalanceSheet.liabilities.totalCurrent)
              },
              nonCurrent: {
                longTermLoans: this.formatLongTermLoans(monthBalanceSheet.liabilities.nonCurrent),
                otherLongTermLiabilities: this.formatOtherLongTermLiabilities(monthBalanceSheet.liabilities.nonCurrent),
                total: Math.abs(monthBalanceSheet.liabilities.totalNonCurrent)
              },
              total: Math.abs(monthBalanceSheet.liabilities.totalLiabilities)
            },
            equity: {
              retainedEarnings: {
                accountCode: '3000',
                accountName: 'Retained Earnings',
                amount: monthBalanceSheet.equity.retainedEarnings // Allow negative values for equity
              },
              otherEquity: {
                accountCode: '3200',
                accountName: 'Other Equity',
                amount: monthBalanceSheet.equity.otherEquity // Allow negative values for equity
              },
              total: monthBalanceSheet.equity.totalEquity
            },
            summary: {
              totalAssets: monthBalanceSheet.assets.totalAssets,
              totalLiabilities: Math.abs(monthBalanceSheet.liabilities.totalLiabilities), // Ensure positive values for liabilities
              totalEquity: monthBalanceSheet.equity.totalEquity, // Allow negative values for equity
              workingCapital: monthBalanceSheet.workingCapital,
              currentRatio: monthBalanceSheet.currentRatio,
              debtToEquity: monthBalanceSheet.debtToEquity
            },
            // Enhanced: Add negotiation details
            negotiations: negotiationDetails
          };
          
          // Return structured data for parallel processing
          return {
            month,
            monthKey,
            monthData: monthlyData[monthKey],
            monthBalanceSheet,
            annualTotals: {
              totalAssets: monthBalanceSheet.assets.totalAssets,
              totalLiabilities: Math.abs(monthBalanceSheet.liabilities.totalLiabilities),
              totalEquity: monthBalanceSheet.equity.totalEquity,
              totalCurrentAssets: monthBalanceSheet.assets.totalCurrent,
              totalNonCurrentAssets: monthBalanceSheet.assets.totalNonCurrent,
              totalCurrentLiabilities: Math.abs(monthBalanceSheet.liabilities.totalCurrent),
              totalNonCurrentLiabilities: Math.abs(monthBalanceSheet.liabilities.totalNonCurrent)
            },
            error: null
          };
          
        } catch (monthError) {
          console.error(`âŒ Error generating balance sheet for month ${month}:`, monthError);
          // Handle error case
          monthlyData[monthKey] = {
            month: monthKey,
            monthName: new Date(year, month - 1, 1).toLocaleDateString('en-US', { month: 'long' }),
            assets: { 
              current: { cashAndBank: {}, accountsReceivable: {}, inventory: {}, prepaidExpenses: {}, total: 0 }, 
              nonCurrent: { propertyPlantEquipment: {}, accumulatedDepreciation: 0, total: 0 }, 
              total: 0 
            },
            liabilities: { 
              current: { accountsPayable: {}, accruedExpenses: {}, tenantDeposits: {}, taxesPayable: {}, total: 0 }, 
              nonCurrent: { longTermLoans: {}, otherLongTermLiabilities: {}, total: 0 }, 
              total: 0 
            },
            equity: { 
              capital: { accountCode: '3000', accountName: 'Owner\'s Capital', amount: 0 }, 
              retainedEarnings: { accountCode: '3100', accountName: 'Retained Earnings', amount: 0 }, 
              otherEquity: { accountCode: '3200', accountName: 'Other Equity', amount: 0 }, 
              total: 0 
            },
            summary: { 
              totalAssets: 0, 
              totalLiabilities: 0, 
              totalEquity: 0, 
              workingCapital: 0, 
              currentRatio: 0, 
              debtToEquity: 0 
            }
          };
        }
        
        // Accumulate annual totals for this month
        if (monthlyData[monthKey] && monthlyData[monthKey].summary) {
          annualSummary.totalAnnualAssets += monthlyData[monthKey].summary.totalAssets || 0;
          annualSummary.totalAnnualLiabilities += monthlyData[monthKey].summary.totalLiabilities || 0;
          annualSummary.totalAnnualEquity += monthlyData[monthKey].summary.totalEquity || 0;
          annualSummary.totalAnnualCurrentAssets += monthlyData[monthKey].assets?.current?.total || 0;
          annualSummary.totalAnnualNonCurrentAssets += monthlyData[monthKey].assets?.nonCurrent?.total || 0;
          annualSummary.totalAnnualCurrentLiabilities += monthlyData[monthKey].liabilities?.current?.total || 0;
          annualSummary.totalAnnualNonCurrentLiabilities += monthlyData[monthKey].liabilities?.nonCurrent?.total || 0;
          
          // Enhanced: Add negotiation totals
          if (monthlyData[monthKey].negotiations) {
            annualSummary.totalNegotiations += monthlyData[monthKey].negotiations.totalNegotiations || 0;
            annualSummary.totalDiscountsGiven += monthlyData[monthKey].negotiations.totalDiscountsGiven || 0;
            if (monthlyData[monthKey].negotiations.studentsAffected) {
              monthlyData[monthKey].negotiations.studentsAffected.forEach(studentId => {
                annualSummary.studentsAffected.add(studentId);
              });
            }
          }
        }
      }
      
      console.log(`âœ… All 12 months processed sequentially`);
      
      // Calculate annual averages (divide by 12 for monthly average)
      annualSummary.totalAnnualAssets = Math.round(annualSummary.totalAnnualAssets / 12);
      annualSummary.totalAnnualLiabilities = Math.round(annualSummary.totalAnnualLiabilities / 12);
      annualSummary.totalAnnualEquity = Math.round(annualSummary.totalAnnualEquity / 12);
      annualSummary.totalAnnualCurrentAssets = Math.round(annualSummary.totalAnnualCurrentAssets / 12);
      annualSummary.totalAnnualNonCurrentAssets = Math.round(annualSummary.totalAnnualNonCurrentAssets / 12);
      annualSummary.totalAnnualCurrentLiabilities = Math.round(annualSummary.totalAnnualCurrentLiabilities / 12);
      annualSummary.totalAnnualNonCurrentLiabilities = Math.round(annualSummary.totalAnnualNonCurrentLiabilities / 12);
      
      // Convert Set to Array for JSON serialization
      annualSummary.studentsAffected = Array.from(annualSummary.studentsAffected);
      
      const result = {
        success: true,
        data: {
          year: year,
          residence: residence || 'all',
          monthly: monthlyData,
          annualSummary: annualSummary
        },
        message: `Monthly balance sheet generated for ${year}${residence ? ` for residence: ${residence}` : ' (all residences)'}`
      };
      
      console.log(`âœ… Monthly Balance Sheet generated successfully for ${year}`);
      return result;
      
    } catch (error) {
      console.error('âŒ Error generating monthly balance sheet:', error);
      throw error;
    }
  }

  /**
   * Generate Monthly Activity Balance Sheet (shows monthly changes, not cumulative balances)
   * This method calculates the change in balances for a specific month
   */
  static async generateMonthlyActivityBalanceSheet(year, month, residence = null, cachedAccounts = null) {
    try {
      console.log(`ðŸ“Š Generating Monthly Activity Balance Sheet for ${year}-${month}${residence ? ` for residence: ${residence}` : ' (all residences)'}`);
      
      const monthStartDate = new Date(year, month - 1, 1); // First day of the month
      const monthEndDate = new Date(year, month, 0); // Last day of the month
      const monthKey = `${year}-${String(month).padStart(2, '0')}`;
      
      // Get transactions that occurred ONLY in this specific month
      const monthQuery = {
        date: { 
          $gte: monthStartDate, 
          $lte: monthEndDate 
        },
        status: 'posted'
      };
      
      if (residence) {
        monthQuery.residence = residence;
      }
      
      // Get all transactions for this month with timeout optimization
      const monthTransactions = await TransactionEntry.find(monthQuery)
        .sort({ date: 1 })
        .maxTimeMS(15000); // 15 second timeout
      
      console.log(`ðŸ” Found ${monthTransactions.length} transactions for ${monthKey}`);
      
      // ðŸš€ OPTIMIZATION: Early exit for months with no transactions
      if (monthTransactions.length === 0) {
        console.log(`âš¡ No transactions found for ${monthKey}, returning zero balance sheet`);
        return {
          asOfDate: monthEndDate,
          residence: residence || 'all',
          assets: { 
            current: {}, 
            nonCurrent: {}, 
            totalCurrent: 0, 
            totalNonCurrent: 0, 
            totalAssets: 0,
            accumulatedDepreciation: 0
          },
          liabilities: { 
            current: {}, 
            nonCurrent: {}, 
            totalCurrent: 0, 
            totalNonCurrent: 0, 
            totalLiabilities: 0 
          },
          equity: { 
            capital: 0, 
            retainedEarnings: 0, 
            otherEquity: 0,
            totalEquity: 0 
          },
          workingCapital: 0,
          currentRatio: 0,
          debtToEquity: 0,
          message: `No transactions found for ${monthKey} - zero balance sheet returned`
        };
      }
      
      // Initialize balance sheet structure for monthly activity
      const balanceSheet = {
        asOfDate: monthEndDate,
        residence: residence || 'all',
        assets: { 
          current: {}, 
          nonCurrent: {}, 
          totalCurrent: 0, 
          totalNonCurrent: 0, 
          totalAssets: 0,
          accumulatedDepreciation: 0
        },
        liabilities: { 
          current: {}, 
          nonCurrent: {}, 
          totalCurrent: 0, 
          totalNonCurrent: 0, 
          totalLiabilities: 0 
        },
        equity: { 
          capital: 0, 
          retainedEarnings: 0, 
          otherEquity: 0,
          totalEquity: 0 
        },
        workingCapital: 0,
        currentRatio: 0,
        debtToEquity: 0,
        message: 'Monthly activity balance sheet generated successfully'
      };
      
      // ðŸš€ OPTIMIZATION: Use cached accounts if provided, otherwise fetch once
      let allAccounts = cachedAccounts;
      if (!allAccounts) {
      const Account = require('../models/Account');
        allAccounts = await Account.find().sort({ code: 1 });
      }
      
      // Initialize account balances for monthly activity
      const accountBalances = {};
      
      // Initialize ALL accounts with zero balances first
      allAccounts.forEach(account => {
        accountBalances[account.code] = {
          code: account.code,
          name: account.name,
          type: account.type,
          debitTotal: 0,
          creditTotal: 0,
          balance: 0,
          description: account.description || '',
          category: account.category || 'Other'
        };
      });
      
      // ðŸš€ OPTIMIZATION: Process transactions more efficiently with batch processing
      console.log(`âš¡ Processing ${monthTransactions.length} transactions with optimized batch processing...`);
      
      // Group transactions by account code for more efficient processing
      const accountTransactionMap = new Map();
      
      monthTransactions.forEach(entry => {
        if (entry.entries && Array.isArray(entry.entries)) {
          entry.entries.forEach(lineItem => {
            const accountCode = lineItem.accountCode;
            const accountName = lineItem.accountName;
            const accountType = lineItem.accountType;
            const debit = lineItem.debit || 0;
            const credit = lineItem.credit || 0;
            
            if (!accountTransactionMap.has(accountCode)) {
              accountTransactionMap.set(accountCode, {
                code: accountCode,
                name: accountName || `Account ${accountCode}`,
                type: accountType || 'Asset',
                debitTotal: 0,
                creditTotal: 0,
                description: '',
                category: 'Other'
              });
            }
            
            const accountData = accountTransactionMap.get(accountCode);
            accountData.debitTotal += debit;
            accountData.creditTotal += credit;
            if (accountName) accountData.name = accountName;
            if (accountType) accountData.type = accountType;
          });
        }
      });
      
      // Apply the transaction data to account balances
      accountTransactionMap.forEach((transactionData, accountCode) => {
            if (accountBalances[accountCode]) {
          accountBalances[accountCode].debitTotal += transactionData.debitTotal;
          accountBalances[accountCode].creditTotal += transactionData.creditTotal;
              // Update name and type from transaction if more recent
          if (transactionData.name) accountBalances[accountCode].name = transactionData.name;
          if (transactionData.type) accountBalances[accountCode].type = transactionData.type;
            } else {
              // Create account if not found in database (fallback)
              accountBalances[accountCode] = {
                code: accountCode,
            name: transactionData.name,
            type: transactionData.type,
            debitTotal: transactionData.debitTotal,
            creditTotal: transactionData.creditTotal,
                balance: 0,
            description: transactionData.description,
            category: transactionData.category
              };
        }
      });
      
      // Calculate net balance for each account (monthly activity)
      Object.values(accountBalances).forEach(account => {
        switch (account.type) {
          case 'Asset':
            account.balance = account.debitTotal - account.creditTotal;
            break;
          case 'Liability':
            account.balance = account.creditTotal - account.debitTotal;
            break;
          case 'Equity':
            account.balance = account.creditTotal - account.debitTotal;
            break;
          case 'Income':
            // Income should be positive (credit > debit means income earned)
            account.balance = account.creditTotal - account.debitTotal;
            break;
          case 'Expense':
            // Expense should be positive (debit > credit means expense incurred)
            account.balance = Math.max(0, account.debitTotal - account.creditTotal);
            break;
        }
      });
      
      // ðŸš€ OPTIMIZATION: Only process accounts with non-zero balances to improve performance
      console.log(`âš¡ Processing only accounts with non-zero balances for better performance...`);
      
      // Categorize into balance sheet sections
      Object.values(accountBalances).forEach(account => {
        const balance = account.balance;
        
        // Skip accounts with zero balance to improve performance
        if (balance === 0) {
          return;
        }
        
        // Use comprehensive category mapping to ensure all accounts are properly categorized
        const mappedCategory = this.mapAccountToCategory(account.code, account.name, account.type);
        
        switch (account.type) {
          case 'Asset':
            if (this.isCurrentAsset(account.code, account.name)) {
              balanceSheet.assets.current[account.code] = {
                name: account.name,
                balance: Math.max(0, balance),
                description: this.getAssetDescription(account.code, account.name),
                category: mappedCategory
              };
              balanceSheet.assets.totalCurrent += Math.max(0, balance);
            } else {
              balanceSheet.assets.nonCurrent[account.code] = {
                name: account.name,
                balance: Math.max(0, balance),
                description: this.getAssetDescription(account.code, account.name),
                category: mappedCategory
              };
              balanceSheet.assets.totalNonCurrent += Math.max(0, balance);
            }
            break;
            
          case 'Liability':
            if (this.isCurrentLiability(account.code, account.name)) {
              balanceSheet.liabilities.current[account.code] = {
                name: account.name,
                balance: Math.abs(balance), // Use absolute value for liabilities
                description: this.getLiabilityDescription(account.code, account.name),
                category: 'Current Liability'
              };
              balanceSheet.liabilities.totalCurrent += Math.abs(balance);
            } else {
              balanceSheet.liabilities.nonCurrent[account.code] = {
                name: account.name,
                balance: Math.abs(balance), // Use absolute value for liabilities
                description: this.getLiabilityDescription(account.code, account.name),
                category: 'Non-Current Liability'
              };
              balanceSheet.liabilities.totalNonCurrent += Math.abs(balance);
            }
            break;
            
          case 'Equity':
            if (account.code === '3000' || account.name.toLowerCase().includes('retained') || account.name.toLowerCase().includes('earnings')) {
              balanceSheet.equity.retainedEarnings += Math.abs(balance); // Use absolute value for retained earnings
            } else if (account.name.toLowerCase().includes('capital')) {
              balanceSheet.equity.capital = Math.abs(balance); // Use absolute value for capital
            } else {
              balanceSheet.equity.otherEquity += Math.abs(balance); // Use absolute value for other equity
            }
            break;
            
          case 'Income':
            // Income increases retained earnings
            balanceSheet.equity.retainedEarnings += balance;
            break;
            
          case 'Expense':
            // Expenses decrease retained earnings
            balanceSheet.equity.retainedEarnings -= balance;
            break;
        }
      });
      
      // AGGREGATE PARENT ACCOUNTS WITH CHILDREN (e.g., Account 2000 + child accounts)
      await this.aggregateParentChildAccounts(balanceSheet);
      
      // Calculate totals and ratios
      balanceSheet.assets.totalAssets = balanceSheet.assets.totalCurrent + balanceSheet.assets.totalNonCurrent;
      // Ensure liability totals are always positive
      balanceSheet.liabilities.totalLiabilities = Math.abs(balanceSheet.liabilities.totalCurrent + balanceSheet.liabilities.totalNonCurrent);
      // Ensure equity totals are always positive
      balanceSheet.equity.totalEquity = balanceSheet.equity.capital + balanceSheet.equity.retainedEarnings + balanceSheet.equity.otherEquity;
      
      // Calculate key ratios
      balanceSheet.workingCapital = balanceSheet.assets.totalCurrent - balanceSheet.liabilities.totalCurrent;
      balanceSheet.currentRatio = balanceSheet.liabilities.totalCurrent > 0 ? 
        balanceSheet.assets.totalCurrent / balanceSheet.liabilities.totalCurrent : 0;
      balanceSheet.debtToEquity = balanceSheet.equity.totalEquity > 0 ? 
        balanceSheet.liabilities.totalLiabilities / balanceSheet.equity.totalEquity : 0;
      
      console.log(`âœ… Monthly Activity Balance Sheet generated for ${monthKey}`);
      return balanceSheet;
      
    } catch (error) {
      console.error('âŒ Error generating monthly activity balance sheet:', error);
      throw error;
    }
  }

  // Enhanced helper methods for formatting data
  static formatCashAndBankAccounts(currentAssets) {
    const cashAndBank = {};
    let total = 0;
    
    console.log('ðŸ” formatCashAndBankAccounts - Processing current assets:', currentAssets);
    
    Object.entries(currentAssets).forEach(([code, asset]) => {
      // Include ALL cash, bank, and petty cash accounts by code pattern
      if (code.startsWith('100') || code.startsWith('101')) {
        console.log(`âœ… Including account in cashAndBank: ${code} - ${asset.name} = $${asset.balance}`);
        
        cashAndBank[code] = {
          accountCode: code,
          accountName: asset.name,
          amount: asset.balance,
          description: asset.description || this.getAssetDescription(code, asset.name),
          category: asset.category || 'Current Asset'
        };
        total += asset.balance;
      } else {
        console.log(`âŒ Excluding account from cashAndBank: ${code} - ${asset.name} = $${asset.balance}`);
      }
    });
    
    cashAndBank.total = total;
    console.log(`ðŸ’° cashAndBank total: $${total}`);
    console.log(`ðŸ“‹ cashAndBank accounts:`, Object.keys(cashAndBank));
    
    return cashAndBank;
  }

  static formatAccountsReceivable(currentAssets) {
    const accountsReceivable = {};
    
    Object.entries(currentAssets).forEach(([code, asset]) => {
      // Look for any account that is an AR account (student-specific or generic)
      if (asset.name.toLowerCase().includes('receivable') || code.startsWith('1100')) {
        accountsReceivable[code] = {
          accountCode: code,
          accountName: asset.name,
          amount: asset.balance,
          description: asset.description,
          category: asset.category
        };
      }
    });
    
    // If no specific AR accounts found, create a default one
    if (Object.keys(accountsReceivable).length === 0) {
      accountsReceivable.default = {
        accountCode: '1100',
        accountName: 'Accounts Receivable - Tenants',
        amount: 0,
        description: 'Accounts receivable from tenants',
        category: 'Current Asset'
      };
    }
    
    return accountsReceivable;
  }

  static formatInventoryAccounts(currentAssets) {
    const inventory = {};
    
    Object.entries(currentAssets).forEach(([code, asset]) => {
      if (asset.name.toLowerCase().includes('inventory') || asset.name.toLowerCase().includes('supplies')) {
        inventory[code] = {
          accountCode: code,
          accountName: asset.name,
          amount: asset.balance,
          description: asset.description,
          category: asset.category
        };
      }
    });
    
    return inventory;
  }

  static formatPrepaidAccounts(currentAssets) {
    const prepaid = {};
    
    Object.entries(currentAssets).forEach(([code, asset]) => {
      if (asset.name.toLowerCase().includes('prepaid')) {
        prepaid[code] = {
          accountCode: code,
          accountName: asset.name,
          amount: asset.balance,
          description: asset.description,
          category: asset.category
        };
      }
    });
    
    return prepaid;
  }

  static formatFixedAssets(nonCurrentAssets) {
    const fixedAssets = {};
    
    Object.entries(nonCurrentAssets).forEach(([code, asset]) => {
      if (asset.name.toLowerCase().includes('property') || 
          asset.name.toLowerCase().includes('equipment') || 
          asset.name.toLowerCase().includes('building') ||
          asset.name.toLowerCase().includes('vehicle')) {
        fixedAssets[code] = {
          accountCode: code,
          accountName: asset.name,
          amount: asset.balance,
          description: asset.description,
          category: asset.category
        };
      }
    });
    
    return fixedAssets;
  }

  static formatAccountsPayable(currentLiabilities) {
    const accountsPayable = {};
    
    Object.entries(currentLiabilities).forEach(([code, liability]) => {
      if (liability.name.toLowerCase().includes('payable')) {
        accountsPayable[code] = {
          accountCode: code,
          accountName: liability.name,
          amount: Math.abs(liability.balance), // FIX: Ensure positive values for liabilities
          description: liability.description,
          category: liability.category
        };
      }
    });
    
    return accountsPayable;
  }

  static formatAccruedExpenses(currentLiabilities) {
    const accrued = {};
    
    Object.entries(currentLiabilities).forEach(([code, liability]) => {
      if (liability.name.toLowerCase().includes('accrued')) {
        accrued[code] = {
          accountCode: code,
          accountName: liability.name,
          amount: Math.abs(liability.balance), // FIX: Ensure positive values for liabilities
          description: liability.description,
          category: liability.category
        };
      }
    });
    
    return accrued;
  }

  static formatTenantDeposits(currentLiabilities) {
    const deposits = {};
    
    Object.entries(currentLiabilities).forEach(([code, liability]) => {
      if (liability.name.toLowerCase().includes('deposit') || 
          liability.name.toLowerCase().includes('deferred') ||
          liability.name.toLowerCase().includes('unearned')) {
        deposits[code] = {
          accountCode: code,
          accountName: liability.name,
          amount: Math.abs(liability.balance), // FIX: Ensure positive values for liabilities
          description: liability.description,
          category: liability.category
        };
      }
    });
    
    return deposits;
  }

  static formatTaxesPayable(currentLiabilities) {
    const taxes = {};
    
    Object.entries(currentLiabilities).forEach(([code, liability]) => {
      if (liability.name.toLowerCase().includes('tax')) {
        taxes[code] = {
          accountCode: code,
          accountName: liability.name,
          amount: Math.abs(liability.balance), // FIX: Ensure positive values for liabilities
          description: liability.description,
          category: liability.category
        };
      }
    });
    
    return taxes;
  }

  static formatDeferredIncome(currentLiabilities) {
    const deferredIncome = {};
    
    Object.entries(currentLiabilities).forEach(([code, liability]) => {
      if (liability.name.toLowerCase().includes('deferred') || 
          liability.name.toLowerCase().includes('unearned') ||
          code === '2030') { // Specifically include account 2030
        deferredIncome[code] = {
          accountCode: code,
          accountName: liability.name,
          amount: Math.abs(liability.balance),
          description: liability.description,
          category: liability.category
        };
      }
    });
    
    return deferredIncome;
  }

  static formatLongTermLoans(nonCurrentLiabilities) {
    const loans = {};
    
    Object.entries(nonCurrentLiabilities).forEach(([code, liability]) => {
      if (liability.name.toLowerCase().includes('loan')) {
        loans[code] = {
          accountCode: code,
          accountName: liability.name,
          amount: Math.abs(liability.balance), // FIX: Ensure positive values for liabilities
          description: liability.description,
          category: liability.category
        };
      }
    });
    
    return loans;
  }

  static formatOtherLongTermLiabilities(nonCurrentLiabilities) {
    const other = {};
    
    Object.entries(nonCurrentLiabilities).forEach(([code, liability]) => {
      if (!liability.name.toLowerCase().includes('loan')) {
        other[code] = {
          accountCode: code,
          accountName: liability.name,
          amount: Math.abs(liability.balance), // FIX: Ensure positive values for liabilities
          category: liability.category
        };
      }
    });
    
    return other;
  }
  
  // Enhanced helper methods for proper classification
  static isCurrentAsset(accountCode, accountName) {
    // Current assets: typically convertible to cash within 12 months
    const currentAssetCodes = ['1000', '1010', '1011', '1012', '1013', '1014', '1100', '1200', '1300', '1400', '1500'];
    const currentAssetNames = ['cash', 'bank', 'petty', 'receivable', 'inventory', 'prepaid', 'short-term', 'current'];
    
    // Non-current assets: long-term assets not easily convertible to cash
    const nonCurrentAssetNames = ['property', 'building', 'equipment', 'furniture', 'vehicle', 'land', 'fixed', 'long-term', 'depreciation', 'accumulated'];
    
    // Check if explicitly non-current first
    if (nonCurrentAssetNames.some(name => accountName.toLowerCase().includes(name))) {
      return false;
    }
    
    return currentAssetCodes.includes(accountCode) || 
           currentAssetNames.some(name => accountName.toLowerCase().includes(name));
  }
  
  // âœ… NEW: Comprehensive account category mapping
  static mapAccountToCategory(accountCode, accountName, accountType) {
    // Map by account code pattern first (most reliable)
    if (accountCode.startsWith('100') || accountCode.startsWith('101')) {
      return 'Current Asset'; // Cash, Bank, Petty Cash
    } else if (accountCode.startsWith('110')) {
      return 'Current Asset'; // Accounts Receivable
    } else if (accountCode.startsWith('120')) {
      return 'Current Asset'; // Inventory
    } else if (accountCode.startsWith('130')) {
      return 'Current Asset'; // Prepaid Expenses
    } else if (accountCode.startsWith('200')) {
      return 'Current Liability'; // Accounts Payable, Deposits, etc.
    } else if (accountCode.startsWith('210')) {
      return 'Current Liability'; // Accrued Expenses
    } else if (accountCode.startsWith('300')) {
      return 'Equity'; // Capital, Retained Earnings
    } else if (accountCode.startsWith('400')) {
      return 'Income'; // Revenue accounts
    } else if (accountCode.startsWith('500')) {
      return 'Expense'; // Expense accounts
    }
    
    // Fallback to name-based mapping
    const nameLower = accountName.toLowerCase();
    if (nameLower.includes('cash') || nameLower.includes('bank') || nameLower.includes('petty')) {
      return 'Current Asset';
    } else if (nameLower.includes('receivable') || nameLower.includes('inventory') || nameLower.includes('prepaid')) {
      return 'Current Asset';
    } else if (nameLower.includes('payable') || nameLower.includes('deposit') || nameLower.includes('accrued')) {
      return 'Current Liability';
    } else if (nameLower.includes('capital') || nameLower.includes('equity') || nameLower.includes('earnings')) {
      return 'Equity';
    } else if (nameLower.includes('revenue') || nameLower.includes('income')) {
      return 'Income';
    } else if (nameLower.includes('expense') || nameLower.includes('cost')) {
      return 'Expense';
    }
    
    // Final fallback based on account type
    switch (accountType) {
      case 'Asset': return 'Current Asset';
      case 'Liability': return 'Current Liability';
      case 'Equity': return 'Equity';
      case 'Income': return 'Income';
      case 'Expense': return 'Expense';
      default: return 'Other';
    }
  }
  
  static isCurrentLiability(accountCode, accountName) {
    const currentLiabilityCodes = ['2000', '2010', '2020', '2030', '2040', '2100', '2200', '2300'];
    const currentLiabilityNames = ['payable', 'accrued', 'deposit', 'tax', 'deferred', 'unearned', 'short term'];
    
    return currentLiabilityCodes.includes(accountCode) || 
           currentLiabilityNames.some(name => accountName.toLowerCase().includes(name));
  }
  
  static getAssetDescription(accountCode, accountName) {
    if (accountCode === '1000' || accountName.toLowerCase().includes('cash')) {
      return 'Cash and cash equivalents';
    } else if (accountCode === '1010' || accountCode === '1011' || accountCode === '1012' || accountCode === '1013' || accountCode === '1014' || accountName.toLowerCase().includes('petty')) {
      return 'Petty cash funds for operational expenses';
    } else if (accountCode === '1100' || accountName.toLowerCase().includes('receivable')) {
      return 'Accounts receivable from tenants';
    } else if (accountCode === '1200' || accountName.toLowerCase().includes('inventory')) {
      return 'Inventory and supplies';
    } else if (accountCode === '1300' || accountName.toLowerCase().includes('prepaid')) {
      return 'Prepaid expenses';
    } else if (accountCode === '3000' || accountName.toLowerCase().includes('property')) {
      return 'Property and buildings';
    } else if (accountCode === '3100' || accountName.toLowerCase().includes('equipment')) {
      return 'Equipment and furniture';
    } else if (accountCode === '3200' || accountName.toLowerCase().includes('vehicle')) {
      return 'Vehicles and transportation';
    } else {
      return 'Other assets';
    }
  }
  
  static getLiabilityDescription(accountCode, accountName) {
    if (accountCode === '2000' || accountName.toLowerCase().includes('payable')) {
      return 'Accounts payable to suppliers';
    } else if (accountCode === '2100' || accountName.toLowerCase().includes('accrued')) {
      return 'Accrued expenses and liabilities';
    } else if (accountCode === '2200' || accountName.toLowerCase().includes('deposit')) {
      return 'Tenant security deposits';
    } else if (accountCode === '2300' || accountName.toLowerCase().includes('tax')) {
      return 'Taxes payable';
    } else if (accountCode === '2400' || accountName.toLowerCase().includes('loan')) {
      return 'Long-term loans and borrowings';
    } else {
      return 'Other liabilities';
    }
  }

  /**
   * Aggregate parent accounts with their child accounts (e.g., Account 2000 + children)
   */
  static async aggregateParentChildAccounts(balanceSheet) {
    try {
      console.log('\nðŸ”— Aggregating parent-child accounts...');
      
      // Get the main Accounts Payable account (2000)
      const Account = require('../models/Account');
      const mainAPAccount = await Account.findOne({ code: '2000' });
      
      if (!mainAPAccount) {
        console.log('âš ï¸ Main Accounts Payable account (2000) not found');
        return;
      }

      // --- ACCOUNTS PAYABLE (2000) AGGREGATION ---
      console.log(`ðŸ” Found AP parent account 2000 with _id: ${mainAPAccount._id} (type: ${typeof mainAPAccount._id})`);
      
      // Get all child accounts of 2000 (handle both string and ObjectId)
      const apChildAccounts = await Account.find({
        $or: [
          { parentAccount: mainAPAccount._id },
          { parentAccount: mainAPAccount._id.toString() },
          { mainAPAccountCode: '2000' },
          { parent: '2000' }
        ],
        isActive: true
      });

      // Also include accounts that start with 200 but aren't 2000
      const apSeriesAccounts = await Account.find({
        code: { $regex: /^200(?!0$)/ }, // starts with 200 but not exactly 2000
        type: 'Liability',
        isActive: true
      });

      // Merge and remove duplicates by code
      const allAPChildrenMap = new Map();
      [...apChildAccounts, ...apSeriesAccounts].forEach(acc => {
        allAPChildrenMap.set(acc.code, acc);
      });
      const allAPChildren = Array.from(allAPChildrenMap.values());

      console.log(`ðŸ”— Found ${allAPChildren.length} Accounts Payable child accounts for parent 2000:`);
      
      // Aggregate child account balances into parent
      if (balanceSheet.liabilities.current['2000']) {
        let totalChildBalance = 0;
        allAPChildren.forEach(childAccount => {
          if (balanceSheet.liabilities.current[childAccount.code] && childAccount.code !== '2000') {
            const childBalance = balanceSheet.liabilities.current[childAccount.code].balance;
            totalChildBalance += childBalance;
            console.log(
              `   â†³ Aggregating ${childAccount.code} (${childAccount.name}): $${childBalance.toFixed(2)}`
            );
          }
        });

        // Add the aggregated child balances to parent
        const originalBalance = balanceSheet.liabilities.current['2000'].balance;
        balanceSheet.liabilities.current['2000'].balance += totalChildBalance;
        balanceSheet.liabilities.current['2000'].aggregated = true;
        balanceSheet.liabilities.current['2000'].childAccounts = allAPChildren.map(c => c.code);
        balanceSheet.liabilities.current['2000'].originalBalance = originalBalance;
        
        console.log(
          `ðŸ“Š Accounts Payable (2000) new total: $${balanceSheet.liabilities.current['2000'].balance.toFixed(2)} (added $${totalChildBalance.toFixed(2)} from ${allAPChildren.length} children)`
        );
      } else {
        console.warn('âš ï¸ Parent AP account (2000) not found in balance sheet');
      }
      
      // Recalculate total current liabilities
      balanceSheet.liabilities.totalCurrent = Object.values(balanceSheet.liabilities.current)
        .reduce((total, liability) => total + liability.balance, 0);
      
      console.log(`âœ… Recalculated total current liabilities: $${balanceSheet.liabilities.totalCurrent}`);
      
    } catch (error) {
      console.error('âŒ Error aggregating parent-child accounts:', error);
      // Don't throw error as this is not critical for balance sheet generation
    }
  }

  /**
   * Get negotiation details for a specific month
   */
  static async getNegotiationDetailsForMonth(asOfDate, residenceId = null) {
    try {
      const TransactionEntry = require('../models/TransactionEntry');
      
      const query = {
        date: { $lte: asOfDate },
        status: 'posted',
        source: 'manual',
        $or: [
          { 'metadata.type': 'negotiated_payment_adjustment' },
          { description: { $regex: /negotiated|discount/i } }
        ]
      };
      
      if (residenceId) {
        query.residence = residenceId;
      }
      
      const negotiationTransactions = await TransactionEntry.find(query);
      
      let totalNegotiations = 0;
      let totalDiscountsGiven = 0;
      const studentsAffected = new Set();
      const studentDetails = {};
      
      for (const transaction of negotiationTransactions) {
        for (const entry of transaction.entries) {
          if (entry.accountCode.startsWith('1100')) {
            totalNegotiations++;
            const discountAmount = entry.credit || 0;
            totalDiscountsGiven += discountAmount;
            
            // Extract student information
            const studentId = this.extractStudentIdFromAccountCode(entry.accountCode);
            const studentName = this.extractStudentNameFromDescription(entry.description) || 
                               this.extractStudentNameFromAccountName(entry.accountName);
            
            studentsAffected.add(studentId);
            
            if (!studentDetails[studentId]) {
              studentDetails[studentId] = {
                studentId,
                studentName,
                totalDiscounts: 0,
                negotiationCount: 0
              };
            }
            
            studentDetails[studentId].totalDiscounts += discountAmount;
            studentDetails[studentId].negotiationCount++;
          }
        }
      }
      
      return {
        totalNegotiations,
        totalDiscountsGiven,
        studentsAffected: Array.from(studentsAffected),
        studentDetails,
        averageDiscountPerNegotiation: totalNegotiations > 0 ? totalDiscountsGiven / totalNegotiations : 0
      };
      
    } catch (error) {
      console.error('âŒ Error getting negotiation details:', error);
      return {
        totalNegotiations: 0,
        totalDiscountsGiven: 0,
        studentsAffected: [],
        studentDetails: {},
        averageDiscountPerNegotiation: 0
      };
    }
  }

  /**
   * Format Accounts Receivable with negotiation details
   */
  static formatAccountsReceivableWithNegotiations(currentAssets, negotiationDetails) {
    const accountsReceivable = this.formatAccountsReceivable(currentAssets);
    
    // Add negotiation breakdown to the main AR account
    if (accountsReceivable['1100']) {
      accountsReceivable['1100'].negotiations = {
        totalNegotiations: negotiationDetails.totalNegotiations,
        totalDiscountsGiven: negotiationDetails.totalDiscountsGiven,
        studentsAffected: negotiationDetails.studentsAffected.length,
        averageDiscountPerNegotiation: negotiationDetails.averageDiscountPerNegotiation,
        studentDetails: negotiationDetails.studentDetails
      };
    }
    
    return accountsReceivable;
  }

  /**
   * Helper methods for extracting student information
   */
  static extractStudentIdFromAccountCode(accountCode) {
    const parts = accountCode.split('-');
    return parts.length > 1 ? parts[1] : accountCode;
  }

  static extractStudentNameFromDescription(description) {
    const match = description.match(/- ([^-]+)$/);
    return match ? match[1].trim() : null;
  }

  static extractStudentNameFromAccountName(accountName) {
    const match = accountName.match(/Accounts Receivable - (.+)$/);
    return match ? match[1].trim() : null;
  }
}

module.exports = BalanceSheetService;



















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































