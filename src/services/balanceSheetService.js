const mongoose = require('mongoose');
const TransactionEntry = require('../models/TransactionEntry');

// Ensure we're using the correct Atlas database connection
const MONGODB_URI = process.env.MONGODB_URI || 'mongodb+srv://macdonaldsairos24:macdonald24@cluster0.ulvve.mongodb.net/test?retryWrites=true&w=majority&appName=Cluster0';

class BalanceSheetService {
  /**
   * Build flexible residence match filter
   * Supports multiple residence field formats and backfills from Request/Expense
   */
  static buildResidenceMatchFilter(residence, existingConditions = {}) {
    if (!residence) return null;
    
    const residenceObjectId = mongoose.Types.ObjectId.isValid(residence) 
      ? new mongoose.Types.ObjectId(residence) 
      : residence;
    
    return {
      $and: [
        existingConditions,
        {
          $or: [
            { residence: residenceObjectId },
            { residence: residence.toString() },
            { 'metadata.residenceId': residenceObjectId },
            { 'metadata.residenceId': residence.toString() },
            { 'metadata.residence': residenceObjectId },
            { 'metadata.residence': residence.toString() }
          ]
        }
      ]
    };
  }

  /**
   * Build residence match filter that also includes transactions affecting non-current asset accounts
   * Non-current assets are only included if they have a matching residence field
   * This ensures non-current assets (like property, equipment) appear on filtered balance sheets only when they belong to that residence
   */
  static buildResidenceMatchFilterWithNonCurrentAssets(residence, existingConditions = {}, nonCurrentAssetCodes = []) {
    if (!residence) return existingConditions;
    
    const residenceObjectId = mongoose.Types.ObjectId.isValid(residence) 
      ? new mongoose.Types.ObjectId(residence) 
      : residence;
    
    // Build the residence match conditions
    const residenceConditions = [
      { residence: residenceObjectId },
      { residence: residence.toString() },
      { 'metadata.residenceId': residenceObjectId },
      { 'metadata.residenceId': residence.toString() },
      { 'metadata.residence': residenceObjectId },
      { 'metadata.residence': residence.toString() }
    ];
    
    // Build conditions for transactions affecting non-current asset accounts
    // IMPORTANT: Non-current assets must ALSO have a matching residence field
    // This ensures that when filtering by residence, only non-current assets belonging to that residence are included
    const nonCurrentAssetConditions = [];
    if (nonCurrentAssetCodes.length > 0) {
      // Check if any entry in the transaction affects a non-current asset account
      // Convert all codes to strings to ensure proper matching
      const nonCurrentAssetCodesStr = nonCurrentAssetCodes.map(code => String(code));
      
      // Non-current asset transactions must have a matching residence field
      nonCurrentAssetConditions.push({
        $and: [
          { 'entries.accountCode': { $in: nonCurrentAssetCodesStr } },
          {
            $or: [
              { residence: residenceObjectId },
              { residence: residence.toString() },
              { 'metadata.residenceId': residenceObjectId },
              { 'metadata.residenceId': residence.toString() },
              { 'metadata.residence': residenceObjectId },
              { 'metadata.residence': residence.toString() }
            ]
          }
        ]
      });
      console.log(`üè¢ Including non-current asset transactions with matching residence: ${nonCurrentAssetCodesStr.slice(0, 10).join(', ')}${nonCurrentAssetCodesStr.length > 10 ? '...' : ''}`);
    }
    
    // Combine: include transactions that match residence OR affect non-current assets with matching residence
    const combinedConditions = [...residenceConditions];
    if (nonCurrentAssetConditions.length > 0) {
      combinedConditions.push(...nonCurrentAssetConditions);
    }
    
    return {
      $and: [
        existingConditions,
        {
          $or: combinedConditions
        }
      ]
    };
  }

  /**
   * Enrich transactions with residence data from Request/Expense references
   * This ensures expense_accrual transactions are properly filtered by residence
   */
  static async enrichTransactionsWithResidence(transactions, residence, dateFilter = { $lte: new Date() }) {
    if (!residence || !transactions || transactions.length === 0) {
      return transactions;
    }
    
    const Request = require('../models/Request');
    const Expense = require('../models/Expense');
    const residenceObjectId = mongoose.Types.ObjectId.isValid(residence) 
      ? new mongoose.Types.ObjectId(residence) 
      : residence;
    
    const enrichedTransactions = [...transactions];
    const existingIds = new Set(transactions.map(t => t._id.toString()));
    
    // Get all expense_accrual transactions that might be linked to this residence
    const expenseAccrualQuery = {
      source: 'expense_accrual',
      date: dateFilter,
      status: 'posted',
      voided: { $ne: true }
    };
    
    const allExpenseAccruals = await TransactionEntry.find(expenseAccrualQuery)
      .sort({ date: 1 })
      .maxTimeMS(20000);
    
    console.log(`üîç Checking ${allExpenseAccruals.length} expense_accrual transactions for residence ${residence}...`);
    
    for (const txn of allExpenseAccruals) {
      if (existingIds.has(txn._id.toString())) continue;
      
      let matchesResidence = false;
      
      // Check if transaction already has residence set
      if (txn.residence) {
        const txnResidence = txn.residence.toString ? txn.residence.toString() : txn.residence;
        if (txnResidence === residenceObjectId.toString() || txnResidence === residence.toString()) {
          matchesResidence = true;
        }
      }
      
      // If not found, check via reference (Request or Expense)
      if (!matchesResidence && txn.reference) {
        try {
          const request = await Request.findById(txn.reference).select('residence');
          if (request && request.residence) {
            const requestResidence = request.residence.toString ? request.residence.toString() : request.residence;
            if (requestResidence === residenceObjectId.toString() || requestResidence === residence.toString()) {
              matchesResidence = true;
              // Update the transaction's residence field for future queries
              await TransactionEntry.updateOne(
                { _id: txn._id },
                { $set: { residence: residenceObjectId } }
              );
              console.log(`‚úÖ Updated transaction ${txn._id} with residence ${residence}`);
            }
          }
          
          if (!matchesResidence) {
            const expense = await Expense.findById(txn.reference).select('residence');
            if (expense && expense.residence) {
              const expenseResidence = expense.residence.toString ? expense.residence.toString() : expense.residence;
              if (expenseResidence === residenceObjectId.toString() || expenseResidence === residence.toString()) {
                matchesResidence = true;
                await TransactionEntry.updateOne(
                  { _id: txn._id },
                  { $set: { residence: residenceObjectId } }
                );
                console.log(`‚úÖ Updated transaction ${txn._id} with residence ${residence}`);
              }
            }
          }
        } catch (err) {
          console.log(`‚ö†Ô∏è Error checking reference ${txn.reference}:`, err.message);
        }
      }
      
      if (matchesResidence) {
        enrichedTransactions.push(txn);
        existingIds.add(txn._id.toString());
      }
    }
    
    console.log(`üìä Total transactions after enrichment: ${enrichedTransactions.length}`);
    return enrichedTransactions;
  }

  /**
   * Generate Balance Sheet for Accrual Basis
   * Assets = Cash + AR + Property + Equipment + Prepaid
   * Liabilities = AP + Loans + Deposits + Accrued Expenses + Taxes
   * Equity = Capital + Retained Earnings (from Income Statement)
   */
  static async generateBalanceSheet(asOfDate, residence = null) {
    try {
      console.log(`üìä Generating Balance Sheet as of ${asOfDate}`);
      
      // Ensure we're connected to the correct Atlas database - wait instead of creating new connection
      if (mongoose.connection.readyState !== 1) {
        console.log('‚ö†Ô∏è Database not connected, waiting for connection...');
        let attempts = 0;
        const maxAttempts = 30;
        while (mongoose.connection.readyState !== 1 && attempts < maxAttempts) {
          await new Promise(resolve => setTimeout(resolve, 1000));
          attempts++;
        }
        if (mongoose.connection.readyState !== 1) {
          throw new Error('Database connection timeout - please ensure database is connected');
        }
      }
      console.log(`üóÑÔ∏è Using database: ${mongoose.connection.db.databaseName}`);
      
      // Use all transactions up to asOfDate (balance sheet should include all historical transactions)
      const asOf = new Date(asOfDate);
      const asOfMonth = asOf.getMonth() + 1;
      const asOfYear = asOf.getFullYear();
      
      // For monthly balance sheets, filter by month to exclude cross-month timezone issues
      // Check if this is a month-end date (last day of month)
      const lastDayOfMonth = new Date(asOfYear, asOfMonth, 0).getDate();
      const isMonthlyBalanceSheet = asOf.getDate() === lastDayOfMonth || asOfDate.toString().includes('31');
      console.log(`üìÖ Month-end balance sheet detected: ${isMonthlyBalanceSheet} (date: ${asOf.toISOString()}, lastDay: ${lastDayOfMonth})`);
      const monthKey = `${asOfYear}-${String(asOfMonth).padStart(2, '0')}`;
      
      // For balance sheet, we need to include:
      // 1. All accruals up to asOf date (rental_accrual, expense_accrual - these create the obligations)
      // 2. All payments up to asOf date (payment, vendor_payment - these settle the obligations)
      // 3. All other transactions up to asOf date (non-payment transactions)
      
      // For balance sheets, always use cumulative filtering (all transactions up to as-of date)
      // Balance sheets should show cumulative balances, not just monthly transactions
      let dateFilter = { $lte: asOf };
      console.log(`üìÖ Using cumulative filter: up to ${asOf.toISOString()}`);
      
      // Note: Removed strict monthly filtering as it was causing balance sheet discrepancies
      // Balance sheets must include all historical transactions to show accurate cumulative balances
      
      // Build base query conditions
      const baseConditions = {
        date: dateFilter,
        status: 'posted',
        voided: { $ne: true }
      };
      
      // Get ALL accounts from the database first to identify non-current asset accounts
      const Account = require('../models/Account');
      const allAccountsForFilter = await Account.find().sort({ code: 1 });
      
      // Identify non-current asset account codes
      // Use both isCurrentAsset check AND category field for more reliable identification
      const nonCurrentAssetCodes = [];
      allAccountsForFilter.forEach(account => {
        if (account.type === 'Asset') {
          // Check if it's a fixed asset by category
          const isFixedAsset = account.category === 'Fixed Assets' || account.category === 'Other Assets';
          // Check if it's non-current by name/code logic
          const isNonCurrentByName = !this.isCurrentAsset(account.code, account.name);
          
          if (isFixedAsset || isNonCurrentByName) {
            nonCurrentAssetCodes.push(account.code);
            console.log(`üè¢ Identified non-current asset: ${account.code} - ${account.name} (category: ${account.category})`);
          }
        }
      });
      console.log(`üè¢ Found ${nonCurrentAssetCodes.length} non-current asset accounts: ${nonCurrentAssetCodes.join(', ')}`);
      
      // Build queries with flexible residence filtering
      const accrualBaseQuery = {
        source: { $in: ['rental_accrual', 'expense_accrual'] },
        ...baseConditions
      };
      
      const paymentBaseQuery = {
        source: { $in: ['payment', 'vendor_payment', 'expense_payment'] },
        ...baseConditions
      };
      
      const otherBaseQuery = {
        source: { $nin: ['rental_accrual', 'expense_accrual', 'payment', 'vendor_payment', 'expense_payment'] },
        ...baseConditions
      };
      
      const manualBaseQuery = {
        source: { $in: ['manual', 'other_income', 'refund', 'negotiated_payment'] },
        ...baseConditions
      };
      
      // Apply flexible residence filtering if residence is provided
      // Include transactions that match residence OR affect non-current asset accounts
      const accrualQuery = residence 
        ? this.buildResidenceMatchFilterWithNonCurrentAssets(residence, accrualBaseQuery, nonCurrentAssetCodes)
        : accrualBaseQuery;
      
      const paymentQuery = residence
        ? this.buildResidenceMatchFilterWithNonCurrentAssets(residence, paymentBaseQuery, nonCurrentAssetCodes)
        : paymentBaseQuery;
      
      const otherQuery = residence
        ? this.buildResidenceMatchFilterWithNonCurrentAssets(residence, otherBaseQuery, nonCurrentAssetCodes)
        : otherBaseQuery;
      
      const manualQuery = residence
        ? this.buildResidenceMatchFilterWithNonCurrentAssets(residence, manualBaseQuery, nonCurrentAssetCodes)
        : manualBaseQuery;
      
      // Get all relevant transactions with timeout optimization
      const [accrualEntries, paymentEntries, otherEntries, manualEntries] = await Promise.all([
        TransactionEntry.find(accrualQuery).sort({ date: 1 }).maxTimeMS(20000), // 20 second timeout
        TransactionEntry.find(paymentQuery).sort({ date: 1 }).maxTimeMS(20000), // 20 second timeout
        TransactionEntry.find(otherQuery).sort({ date: 1 }).maxTimeMS(20000), // 20 second timeout
        TransactionEntry.find(manualQuery).sort({ date: 1 }).maxTimeMS(20000) // 20 second timeout
      ]);
      
      console.log(`üîç Found ${accrualEntries.length} accrual entries, ${paymentEntries.length} payment entries, ${otherEntries.length} other entries, ${manualEntries.length} manual entries`);
      
      // Enrich transactions with residence data from Request/Expense references
      // This ensures expense_accrual transactions are properly included
      let allEntries = [...accrualEntries, ...paymentEntries, ...otherEntries, ...manualEntries];
      if (residence) {
        console.log(`üîç Enriching transactions with residence data for ${residence}...`);
        allEntries = await this.enrichTransactionsWithResidence(allEntries, residence, dateFilter);
        console.log(`üìä Total entries after enrichment: ${allEntries.length}`);
      }
      
      // Debug: Check for advance payments in otherEntries
      const allAdvancePayments = otherEntries.filter(tx => tx.source === 'advance_payment');
      console.log(`üí≥ Found ${allAdvancePayments.length} advance payment transactions in otherEntries for monthKey=${monthKey}`);
      allAdvancePayments.forEach(tx => {
        const txDate = new Date(tx.date);
        const txMonthKey = `${txDate.getFullYear()}-${String(txDate.getMonth() + 1).padStart(2, '0')}`;
        const willMatch = txMonthKey === monthKey;
        console.log(`   - ${tx.transactionId}: date=${txDate.toISOString()}, txMonthKey=${txMonthKey}, monthKey=${monthKey}, match=${willMatch}`);
        
        // Also check what entries this transaction has
        if (tx.entries && Array.isArray(tx.entries)) {
          tx.entries.forEach(line => {
            if (line.accountCode && line.accountCode.startsWith('2200')) {
              const amount = (line.credit || 0) - (line.debit || 0);
              console.log(`     ‚Üí Account ${line.accountCode}: credit=${line.credit}, debit=${line.debit}, amount=${amount}, willInclude=${willMatch}`);
            }
          });
        }
      });
      
      // Check for specific negotiated payment transaction
      const negotiatedPayment = manualEntries.find(tx => tx.transactionId === 'NEG-1757465405612');
      if (negotiatedPayment) {
        console.log(`‚úÖ Found negotiated payment transaction: ${negotiatedPayment.description}`);
        console.log(`   Date: ${negotiatedPayment.date}`);
        console.log(`   Status: ${negotiatedPayment.status}`);
        negotiatedPayment.entries.forEach((entry, index) => {
          console.log(`   Entry ${index + 1}: ${entry.accountCode} - ${entry.accountName} (${entry.accountType})`);
          console.log(`     Debit: $${entry.debit}, Credit: $${entry.credit}`);
          console.log(`     Balance Impact: $${entry.credit - entry.debit}`);
        });
        console.log(`üîç This transaction should reduce AR by $1.84 and reduce income by $1.84`);
      } else {
        console.log(`‚ùå Negotiated payment transaction NEG-1757465405612 not found in manual entries`);
      }
      
      // Initialize balance sheet with proper structure
      const balanceSheet = {
        asOfDate: new Date(asOfDate),
        residence: residence || 'all',
        assets: { 
          current: {}, 
          nonCurrent: {}, 
          totalCurrent: 0, 
          totalNonCurrent: 0, 
          totalAssets: 0,
          accumulatedDepreciation: 0
        },
        liabilities: { 
          current: {}, 
          nonCurrent: {}, 
          totalCurrent: 0, 
          totalNonCurrent: 0, 
          totalLiabilities: 0 
        },
        equity: { 
          capital: 0, 
          retainedEarnings: 0, 
          otherEquity: 0,
          totalEquity: 0 
        },
        workingCapital: 0,
        currentRatio: 0,
        debtToEquity: 0,
        message: 'Balance sheet generated successfully'
      };
      
      // Reuse accounts fetched earlier for filter building
      const allAccounts = allAccountsForFilter;
      
      console.log(`üîç Found ${allEntries.length} transaction entries and ${allAccounts.length} accounts in database`);
      
      // Debug: Show all accounts found
      console.log('üìã All accounts from database:', allAccounts.map(acc => ({ code: acc.code, name: acc.name, type: acc.type })));
      
      // Process entries to build account balances
      const accountBalances = {};
      
      // Initialize ALL accounts with zero balances first
      allAccounts.forEach(account => {
        accountBalances[account.code] = {
          code: account.code,
          name: account.name,
          type: account.type,
          debitTotal: 0,
          creditTotal: 0,
          balance: 0,
          description: account.description || '',
          category: account.category || 'Other'
        };
      });
      
      console.log(`üîç Initialized ${Object.keys(accountBalances).length} accounts from database`);
      
      // Process transaction entries to update balances
      allEntries.forEach(entry => {
        if (entry.entries && Array.isArray(entry.entries)) {
          entry.entries.forEach(lineItem => {
            const accountCode = lineItem.accountCode;
            const accountName = lineItem.accountName;
            const accountType = lineItem.accountType;
            const debit = lineItem.debit || 0;
            const credit = lineItem.credit || 0;
            
            // Debug: Log AR transactions to see credits being processed
            if (accountCode && accountCode.startsWith('1100')) {
              console.log(`üîç Processing AR transaction: ${entry.transactionId} - ${accountCode} - Debit: $${debit}, Credit: $${credit}`);
            }
            
            if (accountBalances[accountCode]) {
              accountBalances[accountCode].debitTotal += debit;
              accountBalances[accountCode].creditTotal += credit;
              // Update name and type from transaction if more recent
              if (accountName) accountBalances[accountCode].name = accountName;
              if (accountType) accountBalances[accountCode].type = accountType;
            } else {
              // Create account if not found in database (fallback)
              accountBalances[accountCode] = {
                code: accountCode,
                name: accountName || `Account ${accountCode}`,
                type: accountType || 'Asset',
                debitTotal: debit,
                creditTotal: credit,
                balance: 0,
                description: '',
                category: 'Other'
              };
            }
          });
        }
      });
      
      console.log(`üîç Account balances after processing transactions:`, Object.keys(accountBalances).length);
      
      // üÜï FIX: Calculate monthSettled-based balances from the already filtered transactions
      try {
        // Calculate AR balance from the filtered transactions
        let arDebits = 0;
        let arCredits = 0;
        let cashByMonth = 0;
        let depositsTotal = 0;
        let deferredTotal = 0;
        
        // Count advance payments for this month (for logging)
        const advancePaymentsInOther = otherEntries.filter(tx => tx.source === 'advance_payment');
        
        // Process accrual entries (AR debits, deposits)
        accrualEntries.forEach(tx => {
          tx.entries.forEach(line => {
            if (line.accountCode && (line.accountCode.startsWith('1100-') || line.accountCode === '1100')) {
              arDebits += Number(line.debit || 0);
            } else if (line.accountCode && line.accountCode.startsWith('2020')) {
              // Deposit accounts (created in accrual entries like lease start)
              depositsTotal += (line.credit || 0) - (line.debit || 0);
            } else if (line.accountCode && line.accountCode.startsWith('2200')) {
              // Deferred income accounts
              deferredTotal += (line.credit || 0) - (line.debit || 0);
            }
          });
        });
        
        // Process payment entries (AR credits, cash, deposits, deferred)
        paymentEntries.forEach(tx => {
          // Check if this is an advance payment (shouldn't be in paymentEntries, but handle it just in case)
          const isAdvancePayment = tx.source === 'advance_payment';
          let txDate = null;
          let txMonthKey = null;
          
          if (isAdvancePayment) {
            txDate = new Date(tx.date);
            txMonthKey = `${txDate.getFullYear()}-${String(txDate.getMonth() + 1).padStart(2, '0')}`;
          }
          
          tx.entries.forEach(line => {
            if (line.accountCode && (line.accountCode.startsWith('1100-') || line.accountCode === '1100')) {
              arCredits += Number(line.credit || 0);
            } else if (line.accountCode && line.accountCode.match(/^100[0-9]/) || line.accountCode === '1000') {
              // Cash accounts - for advance payments, ALWAYS use transaction date; for others, use monthSettled
              if (isAdvancePayment) {
                // For advance payments, use transaction date to determine which month they belong to
                if (isMonthlyBalanceSheet) {
                  // For monthly balance sheets, only include if transaction month matches current month
                  if (txMonthKey === monthKey) {
                cashByMonth += Number(line.debit || 0) - Number(line.credit || 0);
              }
                } else {
                  // For single date balance sheets, include all up to asOfDate (already filtered by dateFilter)
                  cashByMonth += Number(line.debit || 0) - Number(line.credit || 0);
                }
              } else if (tx.metadata?.monthSettled === monthKey) {
                // For non-advance payments, use monthSettled
                cashByMonth += Number(line.debit || 0) - Number(line.credit || 0);
              }
            } else if (line.accountCode && line.accountCode.startsWith('2020')) {
              // Deposit accounts
              depositsTotal += (line.credit || 0) - (line.debit || 0);
            } else if (line.accountCode && line.accountCode.startsWith('2200')) {
              // Deferred income accounts - for advance payments, ALWAYS use transaction date
              if (isAdvancePayment) {
                if (isMonthlyBalanceSheet) {
                  // For monthly balance sheets, only include if transaction month matches current month
                  if (txMonthKey === monthKey) {
              deferredTotal += (line.credit || 0) - (line.debit || 0);
                  }
                } else {
                  // For single date balance sheets, include all up to asOfDate (already filtered by dateFilter)
                  deferredTotal += (line.credit || 0) - (line.debit || 0);
                }
              } else {
                // For non-advance payments, include all (they're already filtered by date)
                deferredTotal += (line.credit || 0) - (line.debit || 0);
              }
            }
          });
        });
        
        // üÜï FIX: Process manual entries (like negotiated payments) for A/R adjustments
        manualEntries.forEach(tx => {
          console.log(`üîç Processing manual transaction: ${tx.transactionId} - ${tx.description}`);
          tx.entries.forEach(line => {
            if (line.accountCode && (line.accountCode.startsWith('1100-') || line.accountCode === '1100')) {
              // Manual transactions affect A/R (like negotiated payment discounts)
              arDebits += Number(line.debit || 0);
              arCredits += Number(line.credit || 0);
              console.log(`  üìù A/R Entry: ${line.accountCode} - Debit: $${line.debit}, Credit: $${line.credit}`);
              console.log(`  üìä Running AR totals: Debits=$${arDebits}, Credits=$${arCredits}, Net=$${arDebits - arCredits}`);
            }
          });
        });
        
        // üÜï FIX: Process other entries for A/R adjustments, deferred income, and cash
        // Use the advancePaymentsInOther variable already declared above
        console.log(`üí≥ Found ${advancePaymentsInOther.length} advance payment transactions in otherEntries for monthKey=${monthKey}`);
        
        // üÜï ENHANCED DEBUGGING: Log details of all advance payments
        advancePaymentsInOther.forEach(tx => {
          const txDate = new Date(tx.date);
          const txMonthKey = `${txDate.getFullYear()}-${String(txDate.getMonth() + 1).padStart(2, '0')}`;
          const willMatch = txMonthKey === monthKey;
          console.log(`   - ${tx.transactionId}: date=${txDate.toISOString()}, txMonthKey=${txMonthKey}, monthKey=${monthKey}, match=${willMatch}, description="${tx.description}"`);
          
          // Also check what entries this transaction has
          if (tx.entries && Array.isArray(tx.entries)) {
            tx.entries.forEach(line => {
              if (line.accountCode && (line.accountCode.startsWith('2200') || line.accountCode === '1000')) {
                const amount = (line.credit || 0) - (line.debit || 0);
                console.log(`     ‚Üí Account ${line.accountCode}: credit=${line.credit}, debit=${line.debit}, amount=${amount}, willInclude=${willMatch}`);
              }
            });
          }
        });
        
        otherEntries.forEach(tx => {
          // For advance payments, use transaction date instead of monthSettled
          // This ensures advance payments appear in the month they were paid, not when they're settled
          const isAdvancePayment = tx.source === 'advance_payment';
          const txDate = new Date(tx.date);
          const txMonthKey = `${txDate.getFullYear()}-${String(txDate.getMonth() + 1).padStart(2, '0')}`;
          
          // üÜï CRITICAL FIX: For advance payments without monthSettled, always use transaction date
          let shouldIncludeDeferred = true;
          let shouldIncludeCash = true;
          
          if (isAdvancePayment) {
            // For advance payments, ALWAYS use transaction date instead of monthSettled
            // This ensures they show up in the month they were paid (e.g., October if paid in October)
            if (isMonthlyBalanceSheet) {
              // For monthly balance sheets: only include if transaction month matches current month
              // This ensures advance payments appear in the month they were paid, not when settled
              shouldIncludeDeferred = (txMonthKey === monthKey);
              shouldIncludeCash = (txMonthKey === monthKey);
              
              console.log(`üí≥ Advance payment check: ${tx.transactionId}, date: ${txDate.toISOString()}, txMonthKey: ${txMonthKey}, monthKey: ${monthKey}, match: ${txMonthKey === monthKey}, includeDeferred: ${shouldIncludeDeferred}, includeCash: ${shouldIncludeCash}`);
            } else {
              // For single date balance sheets, include all up to asOfDate (already filtered by dateFilter)
              shouldIncludeDeferred = true;
              shouldIncludeCash = true;
            }
          }
          
          tx.entries.forEach(line => {
            if (line.accountCode && (line.accountCode.startsWith('1100-') || line.accountCode === '1100')) {
              // Other transactions affect A/R
              arDebits += Number(line.debit || 0);
              arCredits += Number(line.credit || 0);
            } else if (line.accountCode && line.accountCode.startsWith('2200')) {
              // Deferred income accounts (Advance Payment Liability) - use transaction date for advance payments
              if (isAdvancePayment) {
                if (shouldIncludeDeferred) {
                  const amount = (line.credit || 0) - (line.debit || 0);
                  deferredTotal += amount;
                  console.log(`üí≥ Adding advance payment deferred income: ${tx.transactionId}, account: ${line.accountCode}, amount: ${amount}, new total: ${deferredTotal}`);
                } else {
                  console.log(`üí≥ Skipping advance payment deferred income: ${tx.transactionId}, account: ${line.accountCode}, txMonthKey: ${txMonthKey}, monthKey: ${monthKey}, shouldInclude: ${shouldIncludeDeferred}`);
                }
              } else {
                // For non-advance payments, include all (they're already filtered by date)
                deferredTotal += (line.credit || 0) - (line.debit || 0);
              }
            } else if (line.accountCode && line.accountCode.match(/^100[0-9]/) || line.accountCode === '1000') {
              // Cash accounts - for advance payments, use transaction date; for others, use monthSettled
              if (isAdvancePayment) {
                if (shouldIncludeCash) {
                  const amount = Number(line.debit || 0) - Number(line.credit || 0);
                  cashByMonth += amount;
                  console.log(`üí≥ Adding advance payment cash: ${tx.transactionId}, account: ${line.accountCode}, amount: ${amount}, new total: ${cashByMonth}`);
                } else {
                  console.log(`üí≥ Skipping advance payment cash: ${tx.transactionId}, account: ${line.accountCode}, txMonthKey: ${txMonthKey}, monthKey: ${monthKey}, shouldInclude: ${shouldIncludeCash}`);
                }
              } else if (tx.metadata?.monthSettled === monthKey) {
                cashByMonth += Number(line.debit || 0) - Number(line.credit || 0);
              }
            } else if (line.accountCode && line.accountCode.startsWith('2020')) {
              // Deposit accounts
              depositsTotal += (line.credit || 0) - (line.debit || 0);
            }
          });
        });
        
        const arByMonthOutstanding = arDebits - arCredits;
        
        console.log(`üìä Final AR Calculation Summary:`);
        console.log(`   Total AR Debits: $${arDebits}`);
        console.log(`   Total AR Credits: $${arCredits}`);
        console.log(`   Net AR Outstanding: $${arByMonthOutstanding}`);
        
        // Override account balances with monthSettled values
        Object.values(accountBalances).forEach(account => {
          if (account.code && account.code.startsWith('1100-')) {
            // Keep individual AR account balances - don't override with aggregated total
            // This preserves individual transaction effects (like negotiated discounts)
            console.log(`üîç Preserving individual AR account ${account.code} balance: $${account.balance}`);
          } else if (account.code === '1100') {
            // Calculate total AR balance from all individual student AR accounts
            let totalARBalance = 0;
            Object.values(accountBalances).forEach(arAccount => {
              if (arAccount.code && arAccount.code.startsWith('1100-') && arAccount.code !== '1100') {
                totalARBalance += arAccount.balance;
                console.log(`üîç Preserving individual AR account ${arAccount.code} balance: $${arAccount.balance}`);
              }
            });
            
            // Set parent AR account to the aggregated total
            account.balance = totalARBalance;
            account.debitTotal = totalARBalance;
            account.creditTotal = 0;
            console.log(`üìä Parent AR account 1100 aggregated from individual accounts: $${totalARBalance}`);
          } else if (account.code && account.code.match(/^100[0-9]/)) {
            // Override cash accounts with monthSettled calculation
            account.balance = cashByMonth;
            account.debitTotal = cashByMonth;
            account.creditTotal = 0;
          } else if (account.code && account.code.startsWith('2020')) {
            // Override deposit accounts with monthSettled calculation
            account.balance = depositsTotal;
            account.debitTotal = 0;
            account.creditTotal = depositsTotal;
          } else if (account.code && account.code.startsWith('2200')) {
            // Override deferred income accounts with monthSettled calculation
            // IMPORTANT: For monthly balance sheets, deferredTotal only includes transactions for that month
            // For cumulative balance sheets, we need to include all up to asOfDate
            const previousBalance = account.balance;
            const previousCreditTotal = account.creditTotal || 0;
            
            console.log(`üí≥ Setting deferred income (${account.code}) balance: ${deferredTotal} (was: ${previousBalance}, creditTotal was: ${previousCreditTotal}, isMonthly: ${isMonthlyBalanceSheet})`);
            
            // For monthly balance sheets, we only want transactions that match the current month
            // But if deferredTotal is 0 and we had a previous balance that includes advance payments,
            // we need to filter out advance payments from other months
            if (isMonthlyBalanceSheet) {
              // For monthly balance sheets, use the monthSettled calculation
              // This should only include transactions for the current month
            account.balance = deferredTotal;
            account.debitTotal = 0;
            account.creditTotal = deferredTotal;
              
              // Debug: If we're setting to 0 but had a previous balance, check if there are advance payments
              if (deferredTotal === 0 && previousBalance > 0) {
                // Check if there are advance payments in otherEntries for this month
                const advancePaymentsInMonth = otherEntries.filter(tx => {
                  if (tx.source !== 'advance_payment') return false;
                  const txDate = new Date(tx.date);
                  const txMonthKey = `${txDate.getFullYear()}-${String(txDate.getMonth() + 1).padStart(2, '0')}`;
                  return txMonthKey === monthKey;
                });
                
                console.log(`‚ö†Ô∏è Warning: Setting deferred income to 0 for ${monthKey} but previous balance was ${previousBalance}. Found ${advancePaymentsInMonth.length} advance payments in otherEntries for this month.`);
                
                // If we found advance payments but deferredTotal is still 0, recalculate it
                if (advancePaymentsInMonth.length > 0) {
                  console.log(`‚ö†Ô∏è ERROR: Found ${advancePaymentsInMonth.length} advance payments for ${monthKey} but deferredTotal is 0! Recalculating...`);
                  let recalculatedDeferred = 0;
                  advancePaymentsInMonth.forEach(tx => {
                    tx.entries.forEach(line => {
                      if (line.accountCode && line.accountCode.startsWith('2200')) {
                        const amount = (line.credit || 0) - (line.debit || 0);
                        recalculatedDeferred += amount;
                        console.log(`üí≥ Recalculating: ${tx.transactionId}, account: ${line.accountCode}, amount: ${amount}, new total: ${recalculatedDeferred}`);
                      }
                    });
                  });
                  if (recalculatedDeferred > 0) {
                    console.log(`üí≥ Fixing deferred income: using recalculated value ${recalculatedDeferred} instead of 0`);
                    account.balance = recalculatedDeferred;
                    account.creditTotal = recalculatedDeferred;
                    deferredTotal = recalculatedDeferred; // Update for logging
                  }
                }
              }
            } else {
              // For single date balance sheets, deferredTotal should include all up to asOfDate
              // But if deferredTotal is 0 and we had a previous balance, something might be wrong
              if (deferredTotal > 0 || previousBalance === 0) {
                account.balance = deferredTotal;
                account.debitTotal = 0;
                account.creditTotal = deferredTotal;
              } else {
                console.log(`‚ö†Ô∏è Warning: deferredTotal is 0 but previous balance was ${previousBalance}, preserving previous balance`);
              }
            }
          }
        });
        
        console.log(`üÜï MonthSettled reclassification for ${monthKey}: AR=${arByMonthOutstanding}, Cash=${cashByMonth}, Deposits=${depositsTotal}, Deferred=${deferredTotal}`);
        console.log(`üí≥ Advance payment summary for ${monthKey}: Found ${advancePaymentsInOther.length} advance payments, Deferred Income=${deferredTotal}`);
      } catch (error) {
        console.error('Error reclassifying by monthSettled:', error.message);
      }
      
      // Calculate net balance for each account
      Object.values(accountBalances).forEach(account => {
        // Skip recalculation for accounts that were already overridden with monthSettled logic
        // These accounts already have their balance, debitTotal, and creditTotal set correctly
        if (account.code && (account.code.match(/^100[0-9]/) || account.code === '1000' || 
            account.code.startsWith('2020') || account.code.startsWith('2200'))) {
          // These accounts were already processed with monthSettled logic, skip recalculation
          if (account.code.startsWith('2200')) {
            console.log(`üí≥ Preserving deferred income (${account.code}) balance: ${account.balance} (creditTotal: ${account.creditTotal}, debitTotal: ${account.debitTotal})`);
          }
          return; // Skip to next account
        }
        
        switch (account.type) {
          case 'Asset':
            account.balance = account.debitTotal - account.creditTotal;
            // Debug: Log AR account balances to see credits being applied
            if (account.code && account.code.startsWith('1100')) {
              console.log(`üîç AR Account ${account.code} (${account.name}): Debits=$${account.debitTotal}, Credits=$${account.creditTotal}, Balance=$${account.balance}`);
            }
            break;
          case 'Liability':
            account.balance = account.creditTotal - account.debitTotal;
            break;
          case 'Equity':
            account.balance = account.creditTotal - account.debitTotal;
            break;
          case 'Income':
            // Income should be positive (credit > debit means income earned)
            account.balance = account.creditTotal - account.debitTotal;
            break;
          case 'Expense':
            // Expense should be positive (debit > credit means expense incurred)
            account.balance = Math.max(0, account.debitTotal - account.creditTotal);
            break;
        }
      });
      
      // Categorize into balance sheet sections with proper classification
      Object.values(accountBalances).forEach(account => {
        const balance = account.balance;
        
        // Use comprehensive category mapping to ensure all accounts are properly categorized
        const mappedCategory = this.mapAccountToCategory(account.code, account.name, account.type);
        console.log(`üîç Account ${account.code} (${account.name}): type=${account.type}, mapped=${mappedCategory}, balance=$${balance}`);
        
        switch (account.type) {
          case 'Asset':
            // Skip individual AR accounts (1100-*) as they are aggregated under parent AR account (1100)
            if (account.code && account.code.startsWith('1100-')) {
              console.log(`‚è≠Ô∏è Skipping individual AR account ${account.code} - aggregated under parent AR account 1100`);
              break;
            }
            
            if (this.isCurrentAsset(account.code, account.name)) {
              // For AR accounts, allow negative balances to represent legitimate reductions (like negotiated discounts)
              const assetBalance = account.code.startsWith('1100') ? balance : Math.max(0, balance);
              balanceSheet.assets.current[account.code] = {
                name: account.name,
                balance: assetBalance,
                description: this.getAssetDescription(account.code, account.name),
                category: mappedCategory
              };
              balanceSheet.assets.totalCurrent += assetBalance;
              console.log(`‚úÖ Added to current assets: ${account.code} - ${account.name} = $${assetBalance}`);
            } else {
              balanceSheet.assets.nonCurrent[account.code] = {
                name: account.name,
                balance: Math.max(0, balance),
                description: this.getAssetDescription(account.code, account.name),
                category: mappedCategory
              };
              balanceSheet.assets.totalNonCurrent += Math.max(0, balance);
              console.log(`‚úÖ Added to non-current assets: ${account.code} - ${account.name} = $${Math.max(0, balance)}`);
            }
            break;
            
          case 'Liability':
            if (this.isCurrentLiability(account.code, account.name)) {
              balanceSheet.liabilities.current[account.code] = {
                name: account.name,
                balance: Math.abs(balance), // Use absolute value for liabilities
                description: this.getLiabilityDescription(account.code, account.name),
                category: 'Current Liability'
              };
              balanceSheet.liabilities.totalCurrent += Math.abs(balance);
            } else {
              balanceSheet.liabilities.nonCurrent[account.code] = {
                name: account.name,
                balance: Math.abs(balance), // Use absolute value for liabilities
                description: this.getLiabilityDescription(account.code, account.name),
                category: 'Non-Current Liability'
              };
              balanceSheet.liabilities.totalNonCurrent += Math.abs(balance);
            }
            break;
            
          case 'Equity':
            if (account.code === '3000' || account.name.toLowerCase().includes('retained') || account.name.toLowerCase().includes('earnings')) {
              balanceSheet.equity.retainedEarnings += Math.abs(balance); // Use absolute value for retained earnings
            } else if (account.name.toLowerCase().includes('capital')) {
              balanceSheet.equity.capital = Math.abs(balance); // Use absolute value for capital
            } else {
              balanceSheet.equity.otherEquity += Math.abs(balance); // Use absolute value for other equity
            }
            break;
            
          case 'Income':
            // Retained Earnings = Total Income for the Month - Debits/Refunds/Discounts
            // For August: Rental Income $133.00 + Admin Fees $20.00 = $153.00
            balanceSheet.equity.retainedEarnings += balance;
            console.log(`üìà Income account ${account.code} (${account.name}): +$${balance.toLocaleString()} ‚Üí Retained Earnings: $${balanceSheet.equity.retainedEarnings.toLocaleString()}`);
            console.log(`   Account details: Credits=$${account.creditTotal}, Debits=$${account.debitTotal}, Net=$${balance}`);
            break;
            
          case 'Expense':
            // Expenses decrease retained earnings
            balanceSheet.equity.retainedEarnings -= balance;
            console.log(`üìâ Expense account ${account.code} (${account.name}): -$${balance.toLocaleString()} ‚Üí Retained Earnings: $${balanceSheet.equity.retainedEarnings.toLocaleString()}`);
            break;
        }
      });
      
      // AGGREGATE PARENT ACCOUNTS WITH CHILDREN (e.g., Account 2000 + child accounts)
      await this.aggregateParentChildAccounts(balanceSheet);
      
      // Debug: Show all accounts that were processed
      console.log('\nüìä BALANCE SHEET SUMMARY:');
      console.log('Current Assets:', Object.keys(balanceSheet.assets.current));
      console.log('Non-Current Assets:', Object.keys(balanceSheet.assets.nonCurrent));
      console.log('Current Liabilities:', Object.keys(balanceSheet.liabilities.current));
      console.log('Non-Current Liabilities:', Object.keys(balanceSheet.liabilities.nonCurrent));
      console.log('Equity:', Object.keys(balanceSheet.equity));
      
      // Debug: Show specific account processing for petty cash
      console.log('\nüîç PETTY CASH DEBUG:');
      const pettyCashAccounts = Object.values(accountBalances).filter(acc => 
        acc.code.startsWith('101') || acc.name.toLowerCase().includes('petty')
      );
      console.log('Petty cash accounts found:', pettyCashAccounts.map(acc => ({
        code: acc.code,
        name: acc.name,
        type: acc.type,
        balance: acc.balance,
        isCurrentAsset: this.isCurrentAsset(acc.code, acc.name)
      })));
      
      if (pettyCashAccounts.length === 0) {
        console.log('‚ùå NO PETTY CASH ACCOUNTS FOUND!');
      }
      
      // Calculate totals and ratios
      balanceSheet.assets.totalAssets = balanceSheet.assets.totalCurrent + balanceSheet.assets.totalNonCurrent;
      // Ensure liability totals are always positive
      balanceSheet.liabilities.totalLiabilities = Math.abs(balanceSheet.liabilities.totalCurrent + balanceSheet.liabilities.totalNonCurrent);
      // Ensure equity totals are always positive
      balanceSheet.equity.totalEquity = balanceSheet.equity.capital + balanceSheet.equity.retainedEarnings + balanceSheet.equity.otherEquity;
      
      // Calculate key ratios
      balanceSheet.workingCapital = balanceSheet.assets.totalCurrent - balanceSheet.liabilities.totalCurrent;
      balanceSheet.currentRatio = balanceSheet.liabilities.totalCurrent > 0 ? 
        balanceSheet.assets.totalCurrent / balanceSheet.liabilities.totalCurrent : 0;
      balanceSheet.debtToEquity = balanceSheet.equity.totalEquity > 0 ? 
        balanceSheet.liabilities.totalLiabilities / balanceSheet.equity.totalEquity : 0;
      
      // Validate accounting equation: Assets = Liabilities + Equity
      const accountingEquation = Math.abs(
        balanceSheet.assets.totalAssets - 
        (balanceSheet.liabilities.totalLiabilities + balanceSheet.equity.totalEquity)
      );
      
      if (accountingEquation > 0.01) {
        console.warn(`‚ö†Ô∏è Accounting equation imbalance: ${accountingEquation}`);
        
        // Calculate what equity should be based on Assets - Liabilities
        const calculatedEquity = balanceSheet.assets.totalAssets - balanceSheet.liabilities.totalLiabilities;
        const equityDifference = calculatedEquity - balanceSheet.equity.totalEquity;
        
        console.log(`üîç Accounting Equation Analysis:`);
        console.log(`  - Assets: $${balanceSheet.assets.totalAssets.toLocaleString()}`);
        console.log(`  - Liabilities: $${balanceSheet.liabilities.totalLiabilities.toLocaleString()}`);
        console.log(`  - Calculated Equity (Assets - Liabilities): $${calculatedEquity.toLocaleString()}`);
        console.log(`  - Actual Equity from Transactions: $${balanceSheet.equity.totalEquity.toLocaleString()}`);
        console.log(`  - Difference: $${equityDifference.toLocaleString()}`);
        
        // DO NOT auto-correct retained earnings - let it show the actual transaction-based value
        // This difference indicates either:
        // 1. Missing transactions
        // 2. Data entry errors
        // 3. Or legitimate accounting differences that need investigation
        
        balanceSheet.accountingEquation = {
          balanced: false,
          difference: accountingEquation,
          message: `Assets ‚â† Liabilities + Equity - Difference: $${equityDifference.toLocaleString()}. Retained Earnings show actual transaction values.`,
          autoCorrected: false,
          correctionAmount: 0,
          investigationRequired: true
        };
      } else {
        balanceSheet.accountingEquation = {
          balanced: true,
          difference: 0,
          message: 'Assets = Liabilities + Equity ‚úì'
        };
      }
      
      return balanceSheet;
      
    } catch (error) {
      console.error('‚ùå Error generating balance sheet:', error);
      throw error;
    }
  }

  /**
   * Generate Monthly Balance Sheet for React Component
   * This method provides the data structure expected by the React component
   */
  static async generateMonthlyBalanceSheet(year, residence = null, type = 'monthly') {
    try {
      console.log(`üìä Generating Monthly Balance Sheet for ${year}${residence ? ` for residence: ${residence}` : ' (all residences)'} - Type: ${type}`);
      
      const monthlyData = {};
      const annualSummary = {
        totalAnnualAssets: 0,
        totalAnnualLiabilities: 0,
        totalAnnualEquity: 0,
        totalAnnualCurrentAssets: 0,
        totalAnnualNonCurrentAssets: 0,
        totalAnnualCurrentLiabilities: 0,
        totalAnnualNonCurrentLiabilities: 0,
        // Enhanced: Add negotiation tracking
        totalNegotiations: 0,
        totalDiscountsGiven: 0,
        studentsAffected: new Set()
      };
      
      // üöÄ OPTIMIZATION: Cache accounts once to avoid repeated database queries
      console.log(`‚ö° Caching accounts to avoid repeated database queries... [DEPLOYED]`);
      const Account = require('../models/Account');
      
      // Set longer timeout for account fetching
      const cachedAccounts = await Account.find()
        .sort({ code: 1 })
        .maxTimeMS(30000); // 30 second timeout
      console.log(`üìã Cached ${cachedAccounts.length} accounts for reuse across all months`);
      
      // üöÄ OPTIMIZATION: Pre-filter accounts to only include balance sheet relevant ones
      const balanceSheetAccounts = cachedAccounts.filter(account => 
        ['Asset', 'Liability', 'Equity'].includes(account.type)
      );
      console.log(`üìä Filtered to ${balanceSheetAccounts.length} balance sheet relevant accounts`);
      
      // üöÄ OPTIMIZATION: Process months sequentially to avoid database overload
      console.log(`‚ö° Processing months sequentially to prevent database timeout... [DEPLOYED]`);
      
      for (let month = 1; month <= 12; month++) {
        const monthEndDate = new Date(year, month, 0, 23, 59, 59, 999); // Last day of the month with end of day time
        const monthKey = month;
        
        try {
          console.log(`üìÖ Processing month ${month}/${year}...`);
          let monthBalanceSheet;
          
          // Always use cumulative balance calculation to include all transactions up to month end
          // This ensures negotiated payments and other adjustments are properly included
          monthBalanceSheet = await this.generateBalanceSheet(monthEndDate, residence);
          
          // Enhanced: Get negotiation details for this month
          const negotiationDetails = await this.getNegotiationDetailsForMonth(monthEndDate, residence);
          
          // CRITICAL: ALWAYS use aggregated balance from AccountingService.getAccountsPayableWithChildren
          // This is the SAME method account details uses - it returns parent (90) + children (20) = 110
          const AccountingService = require('./accountingService');
          const aggregatedBalance = await AccountingService.getAccountsPayableWithChildren(monthEndDate, residence);
          const aggregatedAmount = Math.abs(aggregatedBalance || 0);
          
          console.log(`üîçüîçüîç ACCOUNTS PAYABLE AGGREGATION:`);
          console.log(`   Raw aggregatedBalance from getAccountsPayableWithChildren: ${aggregatedBalance}`);
          console.log(`   Math.abs(aggregatedBalance): ${aggregatedAmount}`);
          console.log(`   Setting amount to: ${aggregatedAmount}`);
          
          // SET IT DIRECTLY - NO FALLBACKS - ALWAYS use aggregatedAmount
          const accountsPayableFormatted = {
            accountCode: '2000',
            accountName: 'Accounts Payable',
            amount: aggregatedAmount  // ALWAYS use aggregated balance (110)
          };
          
          console.log(`‚úÖ‚úÖ‚úÖ FINAL - accountsPayableFormatted.amount = $${accountsPayableFormatted.amount.toFixed(2)}`);
          console.log(`‚úÖ‚úÖ‚úÖ accountsPayableFormatted object:`, JSON.stringify(accountsPayableFormatted));
          
          // Structure the data as expected by the React component with enhanced structure
          monthlyData[monthKey] = {
            month: monthKey,
            monthName: monthEndDate.toLocaleDateString('en-US', { month: 'long' }),
            assets: {
              current: {
                cashAndBank: this.formatCashAndBankAccounts(monthBalanceSheet.assets.current),
                accountsReceivable: this.formatAccountsReceivableWithNegotiations(monthBalanceSheet.assets.current, negotiationDetails),
                inventory: this.formatInventoryAccounts(monthBalanceSheet.assets.current),
                prepaidExpenses: this.formatPrepaidAccounts(monthBalanceSheet.assets.current),
                total: monthBalanceSheet.assets.totalCurrent
              },
              nonCurrent: {
                propertyPlantEquipment: this.formatFixedAssets(monthBalanceSheet.assets.nonCurrent),
                accumulatedDepreciation: monthBalanceSheet.assets.accumulatedDepreciation,
                total: monthBalanceSheet.assets.totalNonCurrent
              },
              total: monthBalanceSheet.assets.totalAssets
            },
            
            // Debug: Show what's in cashAndBank after formatting (move logs outside object construction)
            liabilities: {
              current: {
                // CRITICAL: Use the aggregated Accounts Payable balance (parent + children = 110)
                // This is set from AccountingService.getAccountsPayableWithChildren above
                accountsPayable: {
                  accountCode: '2000',
                  accountName: 'Accounts Payable',
                  amount: aggregatedAmount  // FORCE use aggregated balance - NO FALLBACKS
                },
                accruedExpenses: this.formatAccruedExpenses(monthBalanceSheet.liabilities.current),
                tenantDeposits: this.formatTenantDeposits(monthBalanceSheet.liabilities.current),
                deferredIncome: this.formatDeferredIncome(monthBalanceSheet.liabilities.current),
                taxesPayable: this.formatTaxesPayable(monthBalanceSheet.liabilities.current),
                total: Math.abs(monthBalanceSheet.liabilities.totalCurrent)
              },
              nonCurrent: {
                longTermLoans: this.formatLongTermLoans(monthBalanceSheet.liabilities.nonCurrent),
                otherLongTermLiabilities: this.formatOtherLongTermLiabilities(monthBalanceSheet.liabilities.nonCurrent),
                total: Math.abs(monthBalanceSheet.liabilities.totalNonCurrent)
              },
              total: Math.abs(monthBalanceSheet.liabilities.totalLiabilities)
            },
            equity: {
              retainedEarnings: {
                accountCode: '3000',
                accountName: 'Retained Earnings',
                amount: monthBalanceSheet.equity.retainedEarnings // Allow negative values for equity
              },
              otherEquity: {
                accountCode: '3200',
                accountName: 'Other Equity',
                amount: monthBalanceSheet.equity.otherEquity // Allow negative values for equity
              },
              total: monthBalanceSheet.equity.totalEquity
            },
            summary: {
              totalAssets: monthBalanceSheet.assets.totalAssets,
              totalLiabilities: Math.abs(monthBalanceSheet.liabilities.totalLiabilities), // Ensure positive values for liabilities
              totalEquity: monthBalanceSheet.equity.totalEquity, // Allow negative values for equity
              workingCapital: monthBalanceSheet.workingCapital,
              currentRatio: monthBalanceSheet.currentRatio,
              debtToEquity: monthBalanceSheet.debtToEquity
            },
            // Enhanced: Add negotiation details
            negotiations: negotiationDetails
          };
          
          // Return structured data for parallel processing
          return {
            month,
            monthKey,
            monthData: monthlyData[monthKey],
            monthBalanceSheet,
            annualTotals: {
              totalAssets: monthBalanceSheet.assets.totalAssets,
              totalLiabilities: Math.abs(monthBalanceSheet.liabilities.totalLiabilities),
              totalEquity: monthBalanceSheet.equity.totalEquity,
              totalCurrentAssets: monthBalanceSheet.assets.totalCurrent,
              totalNonCurrentAssets: monthBalanceSheet.assets.totalNonCurrent,
              totalCurrentLiabilities: Math.abs(monthBalanceSheet.liabilities.totalCurrent),
              totalNonCurrentLiabilities: Math.abs(monthBalanceSheet.liabilities.totalNonCurrent)
            },
            error: null
          };
          
        } catch (monthError) {
          console.error(`‚ùå Error generating balance sheet for month ${month}:`, monthError);
          // Handle error case
          monthlyData[monthKey] = {
            month: monthKey,
            monthName: new Date(year, month - 1, 1).toLocaleDateString('en-US', { month: 'long' }),
            assets: { 
              current: { cashAndBank: {}, accountsReceivable: {}, inventory: {}, prepaidExpenses: {}, total: 0 }, 
              nonCurrent: { propertyPlantEquipment: {}, accumulatedDepreciation: 0, total: 0 }, 
              total: 0 
            },
            liabilities: { 
              current: { accountsPayable: {}, accruedExpenses: {}, tenantDeposits: {}, taxesPayable: {}, total: 0 }, 
              nonCurrent: { longTermLoans: {}, otherLongTermLiabilities: {}, total: 0 }, 
              total: 0 
            },
            equity: { 
              capital: { accountCode: '3000', accountName: 'Owner\'s Capital', amount: 0 }, 
              retainedEarnings: { accountCode: '3100', accountName: 'Retained Earnings', amount: 0 }, 
              otherEquity: { accountCode: '3200', accountName: 'Other Equity', amount: 0 }, 
              total: 0 
            },
            summary: { 
              totalAssets: 0, 
              totalLiabilities: 0, 
              totalEquity: 0, 
              workingCapital: 0, 
              currentRatio: 0, 
              debtToEquity: 0 
            }
          };
        }
        
        // Accumulate annual totals for this month
        if (monthlyData[monthKey] && monthlyData[monthKey].summary) {
          annualSummary.totalAnnualAssets += monthlyData[monthKey].summary.totalAssets || 0;
          annualSummary.totalAnnualLiabilities += monthlyData[monthKey].summary.totalLiabilities || 0;
          annualSummary.totalAnnualEquity += monthlyData[monthKey].summary.totalEquity || 0;
          annualSummary.totalAnnualCurrentAssets += monthlyData[monthKey].assets?.current?.total || 0;
          annualSummary.totalAnnualNonCurrentAssets += monthlyData[monthKey].assets?.nonCurrent?.total || 0;
          annualSummary.totalAnnualCurrentLiabilities += monthlyData[monthKey].liabilities?.current?.total || 0;
          annualSummary.totalAnnualNonCurrentLiabilities += monthlyData[monthKey].liabilities?.nonCurrent?.total || 0;
          
          // Enhanced: Add negotiation totals
          if (monthlyData[monthKey].negotiations) {
            annualSummary.totalNegotiations += monthlyData[monthKey].negotiations.totalNegotiations || 0;
            annualSummary.totalDiscountsGiven += monthlyData[monthKey].negotiations.totalDiscountsGiven || 0;
            if (monthlyData[monthKey].negotiations.studentsAffected) {
              monthlyData[monthKey].negotiations.studentsAffected.forEach(studentId => {
                annualSummary.studentsAffected.add(studentId);
              });
            }
          }
        }
      }
      
      console.log(`‚úÖ All 12 months processed sequentially`);
      
      // Calculate annual averages (divide by 12 for monthly average)
      annualSummary.totalAnnualAssets = Math.round(annualSummary.totalAnnualAssets / 12);
      annualSummary.totalAnnualLiabilities = Math.round(annualSummary.totalAnnualLiabilities / 12);
      annualSummary.totalAnnualEquity = Math.round(annualSummary.totalAnnualEquity / 12);
      annualSummary.totalAnnualCurrentAssets = Math.round(annualSummary.totalAnnualCurrentAssets / 12);
      annualSummary.totalAnnualNonCurrentAssets = Math.round(annualSummary.totalAnnualNonCurrentAssets / 12);
      annualSummary.totalAnnualCurrentLiabilities = Math.round(annualSummary.totalAnnualCurrentLiabilities / 12);
      annualSummary.totalAnnualNonCurrentLiabilities = Math.round(annualSummary.totalAnnualNonCurrentLiabilities / 12);
      
      // Convert Set to Array for JSON serialization
      annualSummary.studentsAffected = Array.from(annualSummary.studentsAffected);
      
      const result = {
        success: true,
        data: {
          year: year,
          residence: residence || 'all',
          monthly: monthlyData,
          annualSummary: annualSummary
        },
        message: `Monthly balance sheet generated for ${year}${residence ? ` for residence: ${residence}` : ' (all residences)'}`
      };
      
      console.log(`‚úÖ Monthly Balance Sheet generated successfully for ${year}`);
      return result;
      
    } catch (error) {
      console.error('‚ùå Error generating monthly balance sheet:', error);
      throw error;
    }
  }

  /**
   * Generate Monthly Activity Balance Sheet (shows monthly changes, not cumulative balances)
   * This method calculates the change in balances for a specific month
   */
  static async generateMonthlyActivityBalanceSheet(year, month, residence = null, cachedAccounts = null) {
    try {
      console.log(`üìä Generating Monthly Activity Balance Sheet for ${year}-${month}${residence ? ` for residence: ${residence}` : ' (all residences)'}`);
      
      const monthStartDate = new Date(year, month - 1, 1); // First day of the month
      const monthEndDate = new Date(year, month, 0); // Last day of the month
      const monthKey = `${year}-${String(month).padStart(2, '0')}`;
      
      // Get transactions that occurred ONLY in this specific month
      const monthQuery = {
        date: { 
          $gte: monthStartDate, 
          $lte: monthEndDate 
        },
        status: 'posted'
      };
      
      if (residence) {
        monthQuery.residence = residence;
      }
      
      // Get all transactions for this month with timeout optimization
      const monthTransactions = await TransactionEntry.find(monthQuery)
        .sort({ date: 1 })
        .maxTimeMS(15000); // 15 second timeout
      
      console.log(`üîç Found ${monthTransactions.length} transactions for ${monthKey}`);
      
      // üöÄ OPTIMIZATION: Early exit for months with no transactions
      if (monthTransactions.length === 0) {
        console.log(`‚ö° No transactions found for ${monthKey}, returning zero balance sheet`);
        return {
          asOfDate: monthEndDate,
          residence: residence || 'all',
          assets: { 
            current: {}, 
            nonCurrent: {}, 
            totalCurrent: 0, 
            totalNonCurrent: 0, 
            totalAssets: 0,
            accumulatedDepreciation: 0
          },
          liabilities: { 
            current: {}, 
            nonCurrent: {}, 
            totalCurrent: 0, 
            totalNonCurrent: 0, 
            totalLiabilities: 0 
          },
          equity: { 
            capital: 0, 
            retainedEarnings: 0, 
            otherEquity: 0,
            totalEquity: 0 
          },
          workingCapital: 0,
          currentRatio: 0,
          debtToEquity: 0,
          message: `No transactions found for ${monthKey} - zero balance sheet returned`
        };
      }
      
      // Initialize balance sheet structure for monthly activity
      const balanceSheet = {
        asOfDate: monthEndDate,
        residence: residence || 'all',
        assets: { 
          current: {}, 
          nonCurrent: {}, 
          totalCurrent: 0, 
          totalNonCurrent: 0, 
          totalAssets: 0,
          accumulatedDepreciation: 0
        },
        liabilities: { 
          current: {}, 
          nonCurrent: {}, 
          totalCurrent: 0, 
          totalNonCurrent: 0, 
          totalLiabilities: 0 
        },
        equity: { 
          capital: 0, 
          retainedEarnings: 0, 
          otherEquity: 0,
          totalEquity: 0 
        },
        workingCapital: 0,
        currentRatio: 0,
        debtToEquity: 0,
        message: 'Monthly activity balance sheet generated successfully'
      };
      
      // üöÄ OPTIMIZATION: Use cached accounts if provided, otherwise fetch once
      let allAccounts = cachedAccounts;
      if (!allAccounts) {
      const Account = require('../models/Account');
        allAccounts = await Account.find().sort({ code: 1 });
      }
      
      // Initialize account balances for monthly activity
      const accountBalances = {};
      
      // Initialize ALL accounts with zero balances first
      allAccounts.forEach(account => {
        accountBalances[account.code] = {
          code: account.code,
          name: account.name,
          type: account.type,
          debitTotal: 0,
          creditTotal: 0,
          balance: 0,
          description: account.description || '',
          category: account.category || 'Other'
        };
      });
      
      // üöÄ OPTIMIZATION: Process transactions more efficiently with batch processing
      console.log(`‚ö° Processing ${monthTransactions.length} transactions with optimized batch processing...`);
      
      // Group transactions by account code for more efficient processing
      const accountTransactionMap = new Map();
      
      monthTransactions.forEach(entry => {
        if (entry.entries && Array.isArray(entry.entries)) {
          entry.entries.forEach(lineItem => {
            const accountCode = lineItem.accountCode;
            const accountName = lineItem.accountName;
            const accountType = lineItem.accountType;
            const debit = lineItem.debit || 0;
            const credit = lineItem.credit || 0;
            
            if (!accountTransactionMap.has(accountCode)) {
              accountTransactionMap.set(accountCode, {
                code: accountCode,
                name: accountName || `Account ${accountCode}`,
                type: accountType || 'Asset',
                debitTotal: 0,
                creditTotal: 0,
                description: '',
                category: 'Other'
              });
            }
            
            const accountData = accountTransactionMap.get(accountCode);
            accountData.debitTotal += debit;
            accountData.creditTotal += credit;
            if (accountName) accountData.name = accountName;
            if (accountType) accountData.type = accountType;
          });
        }
      });
      
      // Apply the transaction data to account balances
      accountTransactionMap.forEach((transactionData, accountCode) => {
            if (accountBalances[accountCode]) {
          accountBalances[accountCode].debitTotal += transactionData.debitTotal;
          accountBalances[accountCode].creditTotal += transactionData.creditTotal;
              // Update name and type from transaction if more recent
          if (transactionData.name) accountBalances[accountCode].name = transactionData.name;
          if (transactionData.type) accountBalances[accountCode].type = transactionData.type;
            } else {
              // Create account if not found in database (fallback)
              accountBalances[accountCode] = {
                code: accountCode,
            name: transactionData.name,
            type: transactionData.type,
            debitTotal: transactionData.debitTotal,
            creditTotal: transactionData.creditTotal,
                balance: 0,
            description: transactionData.description,
            category: transactionData.category
              };
        }
      });
      
      // Calculate net balance for each account (monthly activity)
      Object.values(accountBalances).forEach(account => {
        switch (account.type) {
          case 'Asset':
            account.balance = account.debitTotal - account.creditTotal;
            break;
          case 'Liability':
            account.balance = account.creditTotal - account.debitTotal;
            break;
          case 'Equity':
            account.balance = account.creditTotal - account.debitTotal;
            break;
          case 'Income':
            // Income should be positive (credit > debit means income earned)
            account.balance = account.creditTotal - account.debitTotal;
            break;
          case 'Expense':
            // Expense should be positive (debit > credit means expense incurred)
            account.balance = Math.max(0, account.debitTotal - account.creditTotal);
            break;
        }
      });
      
      // üöÄ OPTIMIZATION: Only process accounts with non-zero balances to improve performance
      console.log(`‚ö° Processing only accounts with non-zero balances for better performance...`);
      
      // Categorize into balance sheet sections
      Object.values(accountBalances).forEach(account => {
        const balance = account.balance;
        
        // Skip accounts with zero balance to improve performance
        if (balance === 0) {
          return;
        }
        
        // Use comprehensive category mapping to ensure all accounts are properly categorized
        const mappedCategory = this.mapAccountToCategory(account.code, account.name, account.type);
        
        switch (account.type) {
          case 'Asset':
            if (this.isCurrentAsset(account.code, account.name)) {
              balanceSheet.assets.current[account.code] = {
                name: account.name,
                balance: Math.max(0, balance),
                description: this.getAssetDescription(account.code, account.name),
                category: mappedCategory
              };
              balanceSheet.assets.totalCurrent += Math.max(0, balance);
            } else {
              balanceSheet.assets.nonCurrent[account.code] = {
                name: account.name,
                balance: Math.max(0, balance),
                description: this.getAssetDescription(account.code, account.name),
                category: mappedCategory
              };
              balanceSheet.assets.totalNonCurrent += Math.max(0, balance);
            }
            break;
            
          case 'Liability':
            if (this.isCurrentLiability(account.code, account.name)) {
              balanceSheet.liabilities.current[account.code] = {
                name: account.name,
                balance: Math.abs(balance), // Use absolute value for liabilities
                description: this.getLiabilityDescription(account.code, account.name),
                category: 'Current Liability'
              };
              balanceSheet.liabilities.totalCurrent += Math.abs(balance);
            } else {
              balanceSheet.liabilities.nonCurrent[account.code] = {
                name: account.name,
                balance: Math.abs(balance), // Use absolute value for liabilities
                description: this.getLiabilityDescription(account.code, account.name),
                category: 'Non-Current Liability'
              };
              balanceSheet.liabilities.totalNonCurrent += Math.abs(balance);
            }
            break;
            
          case 'Equity':
            if (account.code === '3000' || account.name.toLowerCase().includes('retained') || account.name.toLowerCase().includes('earnings')) {
              balanceSheet.equity.retainedEarnings += Math.abs(balance); // Use absolute value for retained earnings
            } else if (account.name.toLowerCase().includes('capital')) {
              balanceSheet.equity.capital = Math.abs(balance); // Use absolute value for capital
            } else {
              balanceSheet.equity.otherEquity += Math.abs(balance); // Use absolute value for other equity
            }
            break;
            
          case 'Income':
            // Income increases retained earnings
            balanceSheet.equity.retainedEarnings += balance;
            break;
            
          case 'Expense':
            // Expenses decrease retained earnings
            balanceSheet.equity.retainedEarnings -= balance;
            break;
        }
      });
      
      // AGGREGATE PARENT ACCOUNTS WITH CHILDREN (e.g., Account 2000 + child accounts)
      await this.aggregateParentChildAccounts(balanceSheet);
      
      // Calculate totals and ratios
      balanceSheet.assets.totalAssets = balanceSheet.assets.totalCurrent + balanceSheet.assets.totalNonCurrent;
      // Ensure liability totals are always positive
      balanceSheet.liabilities.totalLiabilities = Math.abs(balanceSheet.liabilities.totalCurrent + balanceSheet.liabilities.totalNonCurrent);
      // Ensure equity totals are always positive
      balanceSheet.equity.totalEquity = balanceSheet.equity.capital + balanceSheet.equity.retainedEarnings + balanceSheet.equity.otherEquity;
      
      // Calculate key ratios
      balanceSheet.workingCapital = balanceSheet.assets.totalCurrent - balanceSheet.liabilities.totalCurrent;
      balanceSheet.currentRatio = balanceSheet.liabilities.totalCurrent > 0 ? 
        balanceSheet.assets.totalCurrent / balanceSheet.liabilities.totalCurrent : 0;
      balanceSheet.debtToEquity = balanceSheet.equity.totalEquity > 0 ? 
        balanceSheet.liabilities.totalLiabilities / balanceSheet.equity.totalEquity : 0;
      
      console.log(`‚úÖ Monthly Activity Balance Sheet generated for ${monthKey}`);
      return balanceSheet;
      
    } catch (error) {
      console.error('‚ùå Error generating monthly activity balance sheet:', error);
      throw error;
    }
  }

  // Enhanced helper methods for formatting data
  static formatCashAndBankAccounts(currentAssets) {
    const cashAndBank = {};
    let total = 0;
    
    console.log('üîç formatCashAndBankAccounts - Processing current assets:', currentAssets);
    
    Object.entries(currentAssets).forEach(([code, asset]) => {
      // Include ALL cash, bank, and petty cash accounts by code pattern
      if (code.startsWith('100') || code.startsWith('101')) {
        console.log(`‚úÖ Including account in cashAndBank: ${code} - ${asset.name} = $${asset.balance}`);
        
        cashAndBank[code] = {
          accountCode: code,
          accountName: asset.name,
          amount: asset.balance,
          description: asset.description || this.getAssetDescription(code, asset.name),
          category: asset.category || 'Current Asset'
        };
        total += asset.balance;
      } else {
        console.log(`‚ùå Excluding account from cashAndBank: ${code} - ${asset.name} = $${asset.balance}`);
      }
    });
    
    cashAndBank.total = total;
    console.log(`üí∞ cashAndBank total: $${total}`);
    console.log(`üìã cashAndBank accounts:`, Object.keys(cashAndBank));
    
    return cashAndBank;
  }

  static formatAccountsReceivable(currentAssets) {
    const accountsReceivable = {};
    
    Object.entries(currentAssets).forEach(([code, asset]) => {
      // Look for any account that is an AR account (student-specific or generic)
      if (asset.name.toLowerCase().includes('receivable') || code.startsWith('1100')) {
        accountsReceivable[code] = {
          accountCode: code,
          accountName: asset.name,
          amount: asset.balance,
          description: asset.description,
          category: asset.category
        };
      }
    });
    
    // If no specific AR accounts found, create a default one
    if (Object.keys(accountsReceivable).length === 0) {
      accountsReceivable.default = {
        accountCode: '1100',
        accountName: 'Accounts Receivable - Tenants',
        amount: 0,
        description: 'Accounts receivable from tenants',
        category: 'Current Asset'
      };
    }
    
    return accountsReceivable;
  }

  static formatInventoryAccounts(currentAssets) {
    const inventory = {};
    
    Object.entries(currentAssets).forEach(([code, asset]) => {
      if (asset.name.toLowerCase().includes('inventory') || asset.name.toLowerCase().includes('supplies')) {
        inventory[code] = {
          accountCode: code,
          accountName: asset.name,
          amount: asset.balance,
          description: asset.description,
          category: asset.category
        };
      }
    });
    
    return inventory;
  }

  static formatPrepaidAccounts(currentAssets) {
    const prepaid = {};
    
    Object.entries(currentAssets).forEach(([code, asset]) => {
      if (asset.name.toLowerCase().includes('prepaid')) {
        prepaid[code] = {
          accountCode: code,
          accountName: asset.name,
          amount: asset.balance,
          description: asset.description,
          category: asset.category
        };
      }
    });
    
    return prepaid;
  }

  static formatFixedAssets(nonCurrentAssets) {
    const fixedAssets = {};
    
    Object.entries(nonCurrentAssets).forEach(([code, asset]) => {
      if (asset.name.toLowerCase().includes('property') || 
          asset.name.toLowerCase().includes('equipment') || 
          asset.name.toLowerCase().includes('building') ||
          asset.name.toLowerCase().includes('vehicle')) {
        fixedAssets[code] = {
          accountCode: code,
          accountName: asset.name,
          amount: asset.balance,
          description: asset.description,
          category: asset.category
        };
      }
    });
    
    return fixedAssets;
  }

  static formatAccountsPayable(currentLiabilities) {
    // CRITICAL: Prioritize the parent account (2000) which contains the aggregated total
    // The parent account (2000) already includes all child account balances after aggregation
    
    // First, check if parent account (2000) exists - it should have the aggregated balance
    if (currentLiabilities['2000']) {
      const parentAP = currentLiabilities['2000'];
      // CRITICAL: Always use the aggregated balance (parent + children)
      // The balance property should contain the aggregated total after aggregateParentChildAccounts
      // However, we should always verify and use the correct aggregated total
      let aggregatedBalance = Math.abs(parentAP.balance || 0);
      
      // If we have aggregation metadata, use it to ensure correct total
      // This ensures we always use the aggregated balance even if the balance property wasn't updated correctly
      if (parentAP.originalBalance !== undefined && parentAP.totalChildBalance !== undefined) {
        // Calculate the correct aggregated total
        const recalculatedBalance = Math.abs(parentAP.originalBalance || 0) + Math.abs(parentAP.totalChildBalance || 0);
        
        // Use the recalculated balance if it's different (more accurate)
        // The balance property should already be updated by aggregateParentChildAccounts, but verify
        if (Math.abs(recalculatedBalance - aggregatedBalance) > 0.01) {
          console.log(`‚ö†Ô∏è Balance mismatch detected! Balance property: $${aggregatedBalance.toFixed(2)}, Calculated from metadata: $${recalculatedBalance.toFixed(2)}`);
          console.log(`   Using calculated aggregated balance: $${recalculatedBalance.toFixed(2)}`);
          aggregatedBalance = recalculatedBalance;
        }
        
        console.log(`‚úÖ Using aggregated Accounts Payable (2000): $${aggregatedBalance.toFixed(2)}`);
        console.log(`   Parent balance: $${Math.abs(parentAP.originalBalance || 0).toFixed(2)}`);
        console.log(`   Child accounts total: $${Math.abs(parentAP.totalChildBalance || 0).toFixed(2)}`);
        console.log(`   Aggregated flag: ${parentAP.aggregated || false}`);
      } else {
        // No aggregation metadata - use the balance property directly
        // This means either aggregation didn't happen, or metadata wasn't saved
        console.log(`‚ö†Ô∏è Accounts Payable (2000) balance: $${aggregatedBalance.toFixed(2)} (no aggregation metadata found)`);
        console.log(`   Aggregated flag: ${parentAP.aggregated || false}`);
        
        // If not aggregated, try to find child accounts and aggregate manually
        if (!parentAP.aggregated) {
          let childTotal = 0;
          Object.keys(currentLiabilities).forEach(code => {
            if (code !== '2000' && String(code).startsWith('2000')) {
              const childBalance = Math.abs(currentLiabilities[code]?.balance || 0);
              if (childBalance > 0) {
                childTotal += childBalance;
                console.log(`   Found unaggregated child account ${code}: $${childBalance.toFixed(2)}`);
              }
            }
          });
          
          if (childTotal > 0) {
            aggregatedBalance = aggregatedBalance + childTotal;
            console.log(`‚ö†Ô∏è Manually aggregated child accounts: Added $${childTotal.toFixed(2)} to parent balance`);
            console.log(`   New aggregated total: $${aggregatedBalance.toFixed(2)}`);
          }
        }
      }
      
      // Return as both formats: object with key for compatibility, and also include direct access
      // The response might extract the '2000' key or use the object directly
      const formattedAP = {
        accountCode: '2000',
        accountName: parentAP.name || 'Accounts Payable',
        amount: aggregatedBalance, // CRITICAL: Use the aggregated balance (parent + children)
        description: parentAP.description,
        category: parentAP.category || 'Current Liability'
      };
      
      // Return object with key for compatibility, but ensure the aggregated balance is used
      return {
        '2000': formattedAP
      };
    }
    
    // Fallback: if parent account doesn't exist, collect all payable accounts
    const accountsPayable = {};
    Object.entries(currentLiabilities).forEach(([code, liability]) => {
      // Skip child accounts that start with 2000 but aren't exactly 2000
      if (String(code).startsWith('2000') && code !== '2000') {
        console.log(`‚è≠Ô∏è Skipping child account ${code} - should be aggregated into parent (2000)`);
        return;
      }
      
      if (liability.name.toLowerCase().includes('payable')) {
        accountsPayable[code] = {
          accountCode: code,
          accountName: liability.name,
          amount: Math.abs(liability.balance || 0),
          description: liability.description,
          category: liability.category || 'Current Liability'
        };
      }
    });
    
    return accountsPayable;
  }

  static formatAccruedExpenses(currentLiabilities) {
    const accrued = {};
    
    Object.entries(currentLiabilities).forEach(([code, liability]) => {
      if (liability.name.toLowerCase().includes('accrued')) {
        accrued[code] = {
          accountCode: code,
          accountName: liability.name,
          amount: Math.abs(liability.balance), // FIX: Ensure positive values for liabilities
          description: liability.description,
          category: liability.category
        };
      }
    });
    
    return accrued;
  }

  static formatTenantDeposits(currentLiabilities) {
    const deposits = {};
    
    Object.entries(currentLiabilities).forEach(([code, liability]) => {
      if (liability.name.toLowerCase().includes('deposit') || 
          liability.name.toLowerCase().includes('deferred') ||
          liability.name.toLowerCase().includes('unearned')) {
        deposits[code] = {
          accountCode: code,
          accountName: liability.name,
          amount: Math.abs(liability.balance), // FIX: Ensure positive values for liabilities
          description: liability.description,
          category: liability.category
        };
      }
    });
    
    return deposits;
  }

  static formatTaxesPayable(currentLiabilities) {
    const taxes = {};
    
    Object.entries(currentLiabilities).forEach(([code, liability]) => {
      if (liability.name.toLowerCase().includes('tax')) {
        taxes[code] = {
          accountCode: code,
          accountName: liability.name,
          amount: Math.abs(liability.balance), // FIX: Ensure positive values for liabilities
          description: liability.description,
          category: liability.category
        };
      }
    });
    
    return taxes;
  }

  static formatDeferredIncome(currentLiabilities) {
    const deferredIncome = {};
    
    Object.entries(currentLiabilities).forEach(([code, liability]) => {
      if (liability.name.toLowerCase().includes('deferred') || 
          liability.name.toLowerCase().includes('unearned') ||
          code === '2030') { // Specifically include account 2030
        deferredIncome[code] = {
          accountCode: code,
          accountName: liability.name,
          amount: Math.abs(liability.balance),
          description: liability.description,
          category: liability.category
        };
      }
    });
    
    return deferredIncome;
  }

  static formatLongTermLoans(nonCurrentLiabilities) {
    const loans = {};
    
    Object.entries(nonCurrentLiabilities).forEach(([code, liability]) => {
      if (liability.name.toLowerCase().includes('loan')) {
        loans[code] = {
          accountCode: code,
          accountName: liability.name,
          amount: Math.abs(liability.balance), // FIX: Ensure positive values for liabilities
          description: liability.description,
          category: liability.category
        };
      }
    });
    
    return loans;
  }

  static formatOtherLongTermLiabilities(nonCurrentLiabilities) {
    const other = {};
    
    Object.entries(nonCurrentLiabilities).forEach(([code, liability]) => {
      if (!liability.name.toLowerCase().includes('loan')) {
        other[code] = {
          accountCode: code,
          accountName: liability.name,
          amount: Math.abs(liability.balance), // FIX: Ensure positive values for liabilities
          category: liability.category
        };
      }
    });
    
    return other;
  }
  
  // Enhanced helper methods for proper classification
  static isCurrentAsset(accountCode, accountName) {
    // Current assets: typically convertible to cash within 12 months
    const currentAssetCodes = ['1000', '1010', '1011', '1012', '1013', '1014', '1100', '1200', '1300', '1400', '1500'];
    const currentAssetNames = ['cash', 'bank', 'petty', 'receivable', 'inventory', 'prepaid', 'short-term', 'current', 'vault', 'clearing'];
    
    // Non-current assets: long-term assets not easily convertible to cash
    const nonCurrentAssetNames = ['property', 'building', 'equipment', 'furniture', 'vehicle', 'land', 'fixed', 'long-term', 'depreciation', 'accumulated'];
    
    // Check if explicitly non-current first
    if (nonCurrentAssetNames.some(name => accountName.toLowerCase().includes(name))) {
      return false;
    }
    
    // Check if account code starts with 1000-1019 or is 10003, 10005 (cash accounts)
    const isCashAccount = accountCode && (
      accountCode.match(/^10[0-1][0-9]$/) || // 1000-1019
      accountCode === '10003' || // Cbz Vault
      accountCode === '10005' || // Opening balance clearing account
      accountCode.startsWith('1000') // Any account starting with 1000
    );
    
    return isCashAccount ||
           currentAssetCodes.includes(accountCode) || 
           currentAssetNames.some(name => accountName.toLowerCase().includes(name));
  }
  
  // ‚úÖ NEW: Comprehensive account category mapping
  static mapAccountToCategory(accountCode, accountName, accountType) {
    // Map by account code pattern first (most reliable)
    if (accountCode.startsWith('100') || accountCode.startsWith('101')) {
      return 'Current Asset'; // Cash, Bank, Petty Cash
    } else if (accountCode.startsWith('110')) {
      return 'Current Asset'; // Accounts Receivable
    } else if (accountCode.startsWith('120')) {
      return 'Current Asset'; // Inventory
    } else if (accountCode.startsWith('130')) {
      return 'Current Asset'; // Prepaid Expenses
    } else if (accountCode.startsWith('200')) {
      return 'Current Liability'; // Accounts Payable, Deposits, etc.
    } else if (accountCode.startsWith('210')) {
      return 'Current Liability'; // Accrued Expenses
    } else if (accountCode.startsWith('300')) {
      return 'Equity'; // Capital, Retained Earnings
    } else if (accountCode.startsWith('400')) {
      return 'Income'; // Revenue accounts
    } else if (accountCode.startsWith('500')) {
      return 'Expense'; // Expense accounts
    }
    
    // Fallback to name-based mapping
    const nameLower = accountName.toLowerCase();
    if (nameLower.includes('cash') || nameLower.includes('bank') || nameLower.includes('petty')) {
      return 'Current Asset';
    } else if (nameLower.includes('receivable') || nameLower.includes('inventory') || nameLower.includes('prepaid')) {
      return 'Current Asset';
    } else if (nameLower.includes('payable') || nameLower.includes('deposit') || nameLower.includes('accrued')) {
      return 'Current Liability';
    } else if (nameLower.includes('capital') || nameLower.includes('equity') || nameLower.includes('earnings')) {
      return 'Equity';
    } else if (nameLower.includes('revenue') || nameLower.includes('income')) {
      return 'Income';
    } else if (nameLower.includes('expense') || nameLower.includes('cost')) {
      return 'Expense';
    }
    
    // Final fallback based on account type
    switch (accountType) {
      case 'Asset': return 'Current Asset';
      case 'Liability': return 'Current Liability';
      case 'Equity': return 'Equity';
      case 'Income': return 'Income';
      case 'Expense': return 'Expense';
      default: return 'Other';
    }
  }
  
  static isCurrentLiability(accountCode, accountName) {
    const currentLiabilityCodes = ['2000', '2010', '2020', '2030', '2040', '2100', '2200', '2300'];
    const currentLiabilityNames = ['payable', 'accrued', 'deposit', 'tax', 'deferred', 'unearned', 'short term'];
    
    return currentLiabilityCodes.includes(accountCode) || 
           currentLiabilityNames.some(name => accountName.toLowerCase().includes(name));
  }
  
  static getAssetDescription(accountCode, accountName) {
    if (accountCode === '1000' || accountName.toLowerCase().includes('cash')) {
      return 'Cash and cash equivalents';
    } else if (accountCode === '1010' || accountCode === '1011' || accountCode === '1012' || accountCode === '1013' || accountCode === '1014' || accountName.toLowerCase().includes('petty')) {
      return 'Petty cash funds for operational expenses';
    } else if (accountCode === '1100' || accountName.toLowerCase().includes('receivable')) {
      return 'Accounts receivable from tenants';
    } else if (accountCode === '1200' || accountName.toLowerCase().includes('inventory')) {
      return 'Inventory and supplies';
    } else if (accountCode === '1300' || accountName.toLowerCase().includes('prepaid')) {
      return 'Prepaid expenses';
    } else if (accountCode === '3000' || accountName.toLowerCase().includes('property')) {
      return 'Property and buildings';
    } else if (accountCode === '3100' || accountName.toLowerCase().includes('equipment')) {
      return 'Equipment and furniture';
    } else if (accountCode === '3200' || accountName.toLowerCase().includes('vehicle')) {
      return 'Vehicles and transportation';
    } else {
      return 'Other assets';
    }
  }
  
  static getLiabilityDescription(accountCode, accountName) {
    if (accountCode === '2000' || accountName.toLowerCase().includes('payable')) {
      return 'Accounts payable to suppliers';
    } else if (accountCode === '2100' || accountName.toLowerCase().includes('accrued')) {
      return 'Accrued expenses and liabilities';
    } else if (accountCode === '2200' || accountName.toLowerCase().includes('deposit')) {
      return 'Tenant security deposits';
    } else if (accountCode === '2300' || accountName.toLowerCase().includes('tax')) {
      return 'Taxes payable';
    } else if (accountCode === '2400' || accountName.toLowerCase().includes('loan')) {
      return 'Long-term loans and borrowings';
    } else {
      return 'Other liabilities';
    }
  }

  /**
   * Aggregate parent accounts with their child accounts (e.g., Account 2000 + children)
   */
  static async aggregateParentChildAccounts(balanceSheet) {
    try {
      console.log('\nüîó Aggregating parent-child accounts...');
      
      // Get the main Accounts Payable account (2000)
      const Account = require('../models/Account');
      const mainAPAccount = await Account.findOne({ code: '2000' });
      
      if (!mainAPAccount) {
        console.log('‚ö†Ô∏è Main Accounts Payable account (2000) not found');
        return;
      }

      // --- ACCOUNTS PAYABLE (2000) AGGREGATION ---
      console.log(`üîç Found AP parent account 2000 with _id: ${mainAPAccount._id} (type: ${typeof mainAPAccount._id})`);
      
      // Get all child accounts of 2000 (handle both string and ObjectId)
      const apChildAccounts = await Account.find({
        $or: [
          { parentAccount: mainAPAccount._id },
          { parentAccount: mainAPAccount._id.toString() },
          { mainAPAccountCode: '2000' },
          { parent: '2000' }
        ],
        isActive: true
      });

      // Also include accounts that start with 2000 but aren't exactly 2000
      // This matches child accounts like 20001, 20002, 2000-xxx, etc.
      const apSeriesAccounts = await Account.find({
        $or: [
          { code: { $regex: /^2000(?!$)/ } }, // starts with 2000 but not exactly 2000
          { code: { $regex: /^200\d+/ } } // starts with 200 followed by digits (2001, 2002, etc.)
        ],
        type: 'Liability',
        isActive: true
      });

      // Merge and remove duplicates by code
      const allAPChildrenMap = new Map();
      [...apChildAccounts, ...apSeriesAccounts].forEach(acc => {
        allAPChildrenMap.set(acc.code, acc);
      });
      const allAPChildren = Array.from(allAPChildrenMap.values());

      console.log(`üîó Found ${allAPChildren.length} Accounts Payable child accounts for parent 2000:`);
      allAPChildren.forEach(child => {
        console.log(`   - ${child.code} (${child.name})`);
      });
      
      // Aggregate child account balances into parent
      if (balanceSheet.liabilities.current['2000']) {
        // CRITICAL: Get parent account balance FIRST - this must be included in the total
        const parentAccountBalance = balanceSheet.liabilities.current['2000'].balance || 0;
        console.log(`üìä Parent account (2000) balance BEFORE aggregation: $${parentAccountBalance.toFixed(2)}`);
        
        let totalChildBalance = 0;
        
        // First, aggregate explicitly linked child accounts
        allAPChildren.forEach(childAccount => {
          if (balanceSheet.liabilities.current[childAccount.code] && childAccount.code !== '2000') {
            const childBalance = balanceSheet.liabilities.current[childAccount.code].balance;
            totalChildBalance += childBalance;
            console.log(
              `   ‚Ü≥ Aggregating ${childAccount.code} (${childAccount.name}): $${childBalance.toFixed(2)}`
            );
          } else if (childAccount.code !== '2000') {
            console.log(`   ‚ö†Ô∏è Child account ${childAccount.code} (${childAccount.name}) not found in balanceSheet.liabilities.current`);
          }
        });
        
        // Also check for any accounts in the balance sheet that start with 2000 but aren't exactly 2000
        // This catches child accounts that might not be explicitly linked
        Object.keys(balanceSheet.liabilities.current).forEach(code => {
          if (code !== '2000' && String(code).startsWith('2000')) {
            // Check if this account wasn't already aggregated
            const alreadyAggregated = allAPChildren.some(child => child.code === code);
            if (!alreadyAggregated) {
              const childBalance = balanceSheet.liabilities.current[code].balance;
              if (childBalance !== 0) {
                totalChildBalance += childBalance;
                console.log(
                  `   ‚Ü≥ Aggregating implicit child account ${code} (${balanceSheet.liabilities.current[code].name}): $${childBalance.toFixed(2)}`
                );
              }
            }
          }
        });

        // Add the aggregated child balances to parent
        // IMPORTANT: The parent account (2000) balance should ALWAYS be included in the total
        // We start with the parent's own balance and add child account balances to it
        // Use the parentAccountBalance we captured at the start to ensure it's not modified
        const originalBalance = parentAccountBalance;
        const aggregatedTotal = originalBalance + totalChildBalance;
        
        console.log(`üìä Aggregation calculation:` +
          `\n   Parent account (2000) own balance: $${originalBalance.toFixed(2)}` +
          `\n   Total child accounts balance: $${totalChildBalance.toFixed(2)}` +
          `\n   Calculation: ${originalBalance.toFixed(2)} + ${totalChildBalance.toFixed(2)} = ${aggregatedTotal.toFixed(2)}`
        );
        
        // Set the aggregated total (parent balance + all child balances)
        balanceSheet.liabilities.current['2000'].balance = aggregatedTotal;
        balanceSheet.liabilities.current['2000'].aggregated = true;
        balanceSheet.liabilities.current['2000'].childAccounts = allAPChildren.map(c => c.code);
        balanceSheet.liabilities.current['2000'].originalBalance = originalBalance;
        balanceSheet.liabilities.current['2000'].totalChildBalance = totalChildBalance;
        
        console.log(
          `üìä Accounts Payable (2000) aggregation:` +
          `\n   Parent account balance: $${originalBalance.toFixed(2)}` +
          `\n   Child accounts total: $${totalChildBalance.toFixed(2)} (from ${allAPChildren.length} children)` +
          `\n   AGGREGATED TOTAL: $${aggregatedTotal.toFixed(2)}`
        );
      } else {
        console.warn('‚ö†Ô∏è Parent AP account (2000) not found in balance sheet');
      }
      
      // Recalculate total current liabilities
      // IMPORTANT: Exclude child accounts that have been aggregated into the parent to avoid double-counting
      // The parent account (2000) now contains the aggregated total (parent + children)
      const aggregatedChildCodes = new Set();
      if (balanceSheet.liabilities.current['2000'] && balanceSheet.liabilities.current['2000'].childAccounts) {
        balanceSheet.liabilities.current['2000'].childAccounts.forEach(code => {
          aggregatedChildCodes.add(String(code));
        });
      }
      
      // Also exclude any accounts that start with 2000 but aren't exactly 2000 (implicit children)
      balanceSheet.liabilities.totalCurrent = Object.entries(balanceSheet.liabilities.current)
        .filter(([code, liability]) => {
          // Always include the parent account (2000)
          if (code === '2000') return true;
          // Exclude child accounts that start with 2000 but aren't exactly 2000
          if (String(code).startsWith('2000') && code !== '2000') return false;
          // Exclude explicitly aggregated child accounts
          if (aggregatedChildCodes.has(String(code))) return false;
          return true;
        })
        .reduce((total, [code, liability]) => {
          const balance = Math.abs(liability.balance || 0);
          console.log(`   üìä Including ${code} (${liability.name}): $${balance.toFixed(2)}`);
          return total + balance;
        }, 0);
      
      console.log(`‚úÖ Recalculated total current liabilities: $${balanceSheet.liabilities.totalCurrent}`);
      console.log(`   Excluded ${aggregatedChildCodes.size} child accounts that were aggregated into parent (2000)`);
      
    } catch (error) {
      console.error('‚ùå Error aggregating parent-child accounts:', error);
      // Don't throw error as this is not critical for balance sheet generation
    }
  }

  /**
   * Get negotiation details for a specific month
   */
  static async getNegotiationDetailsForMonth(asOfDate, residenceId = null) {
    try {
      const TransactionEntry = require('../models/TransactionEntry');
      
      const query = {
        date: { $lte: asOfDate },
        status: 'posted',
        source: 'manual',
        $or: [
          { 'metadata.type': 'negotiated_payment_adjustment' },
          { description: { $regex: /negotiated|discount/i } }
        ]
      };
      
      if (residenceId) {
        query.residence = residenceId;
      }
      
      const negotiationTransactions = await TransactionEntry.find(query);
      
      let totalNegotiations = 0;
      let totalDiscountsGiven = 0;
      const studentsAffected = new Set();
      const studentDetails = {};
      
      for (const transaction of negotiationTransactions) {
        for (const entry of transaction.entries) {
          if (entry.accountCode.startsWith('1100')) {
            totalNegotiations++;
            const discountAmount = entry.credit || 0;
            totalDiscountsGiven += discountAmount;
            
            // Extract student information
            const studentId = this.extractStudentIdFromAccountCode(entry.accountCode);
            const studentName = this.extractStudentNameFromDescription(entry.description) || 
                               this.extractStudentNameFromAccountName(entry.accountName);
            
            studentsAffected.add(studentId);
            
            if (!studentDetails[studentId]) {
              studentDetails[studentId] = {
                studentId,
                studentName,
                totalDiscounts: 0,
                negotiationCount: 0
              };
            }
            
            studentDetails[studentId].totalDiscounts += discountAmount;
            studentDetails[studentId].negotiationCount++;
          }
        }
      }
      
      return {
        totalNegotiations,
        totalDiscountsGiven,
        studentsAffected: Array.from(studentsAffected),
        studentDetails,
        averageDiscountPerNegotiation: totalNegotiations > 0 ? totalDiscountsGiven / totalNegotiations : 0
      };
      
    } catch (error) {
      console.error('‚ùå Error getting negotiation details:', error);
      return {
        totalNegotiations: 0,
        totalDiscountsGiven: 0,
        studentsAffected: [],
        studentDetails: {},
        averageDiscountPerNegotiation: 0
      };
    }
  }

  /**
   * Format Accounts Receivable with negotiation details
   */
  static formatAccountsReceivableWithNegotiations(currentAssets, negotiationDetails) {
    const accountsReceivable = this.formatAccountsReceivable(currentAssets);
    
    // Add negotiation breakdown to the main AR account
    if (accountsReceivable['1100']) {
      accountsReceivable['1100'].negotiations = {
        totalNegotiations: negotiationDetails.totalNegotiations,
        totalDiscountsGiven: negotiationDetails.totalDiscountsGiven,
        studentsAffected: negotiationDetails.studentsAffected.length,
        averageDiscountPerNegotiation: negotiationDetails.averageDiscountPerNegotiation,
        studentDetails: negotiationDetails.studentDetails
      };
    }
    
    return accountsReceivable;
  }

  /**
   * Helper methods for extracting student information
   */
  static extractStudentIdFromAccountCode(accountCode) {
    const parts = accountCode.split('-');
    return parts.length > 1 ? parts[1] : accountCode;
  }

  static extractStudentNameFromDescription(description) {
    const match = description.match(/- ([^-]+)$/);
    return match ? match[1].trim() : null;
  }

  static extractStudentNameFromAccountName(accountName) {
    const match = accountName.match(/Accounts Receivable - (.+)$/);
    return match ? match[1].trim() : null;
  }
}

module.exports = BalanceSheetService;



















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































