const mongoose = require('mongoose');
const TransactionEntry = require('../models/TransactionEntry');

class BalanceSheetService {
  /**
   * Generate Balance Sheet for Accrual Basis
   * Assets = Cash + AR + Property + Equipment + Prepaid
   * Liabilities = AP + Loans + Deposits + Accrued Expenses + Taxes
   * Equity = Capital + Retained Earnings (from Income Statement)
   */
  static async generateBalanceSheet(asOfDate, residence = null) {
    try {
      console.log(`üìä Generating Balance Sheet as of ${asOfDate}`);
      
      // Use all transactions up to asOfDate (balance sheet should include all historical transactions)
      const asOf = new Date(asOfDate);
      const asOfMonth = asOf.getMonth() + 1;
      const asOfYear = asOf.getFullYear();
      const monthKey = `${asOfYear}-${String(asOfMonth).padStart(2, '0')}`;
      
      // For balance sheet, we need to include:
      // 1. All accruals up to asOf date (these create the obligations)
      // 2. All payments with monthSettled <= current month (these settle the obligations)
      // 3. All other transactions up to asOf date (non-payment transactions)
      
      const accrualQuery = {
        source: 'rental_accrual',
        date: { $lte: asOf },
        status: 'posted'
      };
      
      const paymentQuery = {
        source: 'payment',
        'metadata.monthSettled': { $lte: monthKey },
        status: 'posted'
      };
      
      const otherQuery = {
        source: { $nin: ['rental_accrual', 'payment'] },
        date: { $lte: asOf },
        status: 'posted'
      };
      
      if (residence) {
        accrualQuery.residence = residence;
        paymentQuery.residence = residence;
        otherQuery.residence = residence;
      }
      
      // Get all relevant transactions
      const [accrualEntries, paymentEntries, otherEntries] = await Promise.all([
        TransactionEntry.find(accrualQuery).sort({ date: 1 }),
        TransactionEntry.find(paymentQuery).sort({ date: 1 }),
        TransactionEntry.find(otherQuery).sort({ date: 1 })
      ]);
      
      const allEntries = [...accrualEntries, ...paymentEntries, ...otherEntries];
      
      // Initialize balance sheet with proper structure
      const balanceSheet = {
        asOfDate: new Date(asOfDate),
        residence: residence || 'all',
        assets: { 
          current: {}, 
          nonCurrent: {}, 
          totalCurrent: 0, 
          totalNonCurrent: 0, 
          totalAssets: 0,
          accumulatedDepreciation: 0
        },
        liabilities: { 
          current: {}, 
          nonCurrent: {}, 
          totalCurrent: 0, 
          totalNonCurrent: 0, 
          totalLiabilities: 0 
        },
        equity: { 
          capital: 0, 
          retainedEarnings: 0, 
          otherEquity: 0,
          totalEquity: 0 
        },
        workingCapital: 0,
        currentRatio: 0,
        debtToEquity: 0,
        message: 'Balance sheet generated successfully'
      };
      
      // Get ALL accounts from the database to ensure none are missing
      const Account = require('../models/Account');
      const allAccounts = await Account.find().sort({ code: 1 });
      
      console.log(`üîç Found ${allEntries.length} transaction entries and ${allAccounts.length} accounts in database`);
      
      // Debug: Show all accounts found
      console.log('üìã All accounts from database:', allAccounts.map(acc => ({ code: acc.code, name: acc.name, type: acc.type })));
      
      // Process entries to build account balances
      const accountBalances = {};
      
      // Initialize ALL accounts with zero balances first
      allAccounts.forEach(account => {
        accountBalances[account.code] = {
          code: account.code,
          name: account.name,
          type: account.type,
          debitTotal: 0,
          creditTotal: 0,
          balance: 0,
          description: account.description || '',
          category: account.category || 'Other'
        };
      });
      
      console.log(`üîç Initialized ${Object.keys(accountBalances).length} accounts from database`);
      
      // Process transaction entries to update balances
      allEntries.forEach(entry => {
        if (entry.entries && Array.isArray(entry.entries)) {
          entry.entries.forEach(lineItem => {
            const accountCode = lineItem.accountCode;
            const accountName = lineItem.accountName;
            const accountType = lineItem.accountType;
            const debit = lineItem.debit || 0;
            const credit = lineItem.credit || 0;
            
            if (accountBalances[accountCode]) {
              accountBalances[accountCode].debitTotal += debit;
              accountBalances[accountCode].creditTotal += credit;
              // Update name and type from transaction if more recent
              if (accountName) accountBalances[accountCode].name = accountName;
              if (accountType) accountBalances[accountCode].type = accountType;
            } else {
              // Create account if not found in database (fallback)
              accountBalances[accountCode] = {
                code: accountCode,
                name: accountName || `Account ${accountCode}`,
                type: accountType || 'Asset',
                debitTotal: debit,
                creditTotal: credit,
                balance: 0,
                description: '',
                category: 'Other'
              };
            }
          });
        }
      });
      
      console.log(`üîç Account balances after processing transactions:`, Object.keys(accountBalances).length);
      
      // üÜï FIX: Calculate monthSettled-based balances from the already filtered transactions
      try {
        // Calculate AR balance from the filtered transactions
        let arDebits = 0;
        let arCredits = 0;
        let cashByMonth = 0;
        let depositsTotal = 0;
        let deferredTotal = 0;
        
        // Process accrual entries (AR debits)
        accrualEntries.forEach(tx => {
          tx.entries.forEach(line => {
            if (line.accountCode && (line.accountCode.startsWith('1100-') || line.accountCode === '1100')) {
              arDebits += Number(line.debit || 0);
            }
          });
        });
        
        // Process payment entries (AR credits, cash, deposits, deferred)
        paymentEntries.forEach(tx => {
          tx.entries.forEach(line => {
            if (line.accountCode && (line.accountCode.startsWith('1100-') || line.accountCode === '1100')) {
              arCredits += Number(line.credit || 0);
            } else if (line.accountCode && line.accountCode.match(/^100[0-9]/)) {
              // Cash accounts - only include if monthSettled = current month
              if (tx.metadata?.monthSettled === monthKey) {
                cashByMonth += Number(line.debit || 0) - Number(line.credit || 0);
              }
            } else if (line.accountCode === '1000') {
              // Main cash account - only include if monthSettled = current month
              if (tx.metadata?.monthSettled === monthKey) {
                cashByMonth += Number(line.debit || 0) - Number(line.credit || 0);
              }
            } else if (line.accountCode && line.accountCode.startsWith('2020')) {
              // Deposit accounts
              depositsTotal += (line.credit || 0) - (line.debit || 0);
            } else if (line.accountCode && line.accountCode.startsWith('2200')) {
              // Deferred income accounts
              deferredTotal += (line.credit || 0) - (line.debit || 0);
            }
          });
        });
        
        const arByMonthOutstanding = arDebits - arCredits;
        
        // Calculate individual AR account balances properly
        const arAccountBalances = {};
        
        // Process accrual entries to get individual AR account debits
        accrualEntries.forEach(tx => {
          tx.entries.forEach(line => {
            if (line.accountCode && (line.accountCode.startsWith('1100-') || line.accountCode === '1100')) {
              if (!arAccountBalances[line.accountCode]) {
                arAccountBalances[line.accountCode] = { debits: 0, credits: 0 };
              }
              arAccountBalances[line.accountCode].debits += Number(line.debit || 0);
            }
          });
        });
        
        // Process payment entries to get individual AR account credits
        paymentEntries.forEach(tx => {
          tx.entries.forEach(line => {
            if (line.accountCode && (line.accountCode.startsWith('1100-') || line.accountCode === '1100')) {
              if (!arAccountBalances[line.accountCode]) {
                arAccountBalances[line.accountCode] = { debits: 0, credits: 0 };
              }
              arAccountBalances[line.accountCode].credits += Number(line.credit || 0);
            }
          });
        });
        
        // Override account balances with monthSettled values
        Object.values(accountBalances).forEach(account => {
          if (account.code && (account.code.startsWith('1100-') || account.code === '1100')) {
            // Calculate individual AR account balance
            const arBalance = arAccountBalances[account.code] || { debits: 0, credits: 0 };
            account.balance = arBalance.debits - arBalance.credits;
            account.debitTotal = arBalance.debits;
            account.creditTotal = arBalance.credits;
          } else if (account.code && account.code.match(/^100[0-9]/)) {
            // Override cash accounts with monthSettled calculation
            account.balance = cashByMonth;
            account.debitTotal = cashByMonth;
            account.creditTotal = 0;
          } else if (account.code && account.code.startsWith('2020')) {
            // Override deposit accounts with monthSettled calculation
            account.balance = depositsTotal;
            account.debitTotal = 0;
            account.creditTotal = depositsTotal;
          } else if (account.code && account.code.startsWith('2200')) {
            // Override deferred income accounts with monthSettled calculation
            account.balance = deferredTotal;
            account.debitTotal = 0;
            account.creditTotal = deferredTotal;
          }
        });
        
        console.log(`üÜï MonthSettled reclassification for ${monthKey}: AR=${arByMonthOutstanding}, Cash=${cashByMonth}, Deposits=${depositsTotal}, Deferred=${deferredTotal}`);
      } catch (error) {
        console.error('Error reclassifying by monthSettled:', error.message);
      }
      
      // Calculate net balance for each account
      Object.values(accountBalances).forEach(account => {
        switch (account.type) {
          case 'Asset':
            account.balance = account.debitTotal - account.creditTotal;
            break;
          case 'Liability':
            account.balance = account.creditTotal - account.debitTotal;
            break;
          case 'Equity':
            account.balance = account.creditTotal - account.debitTotal;
            break;
          case 'Income':
            // Income should be positive (credit > debit means income earned)
            account.balance = Math.max(0, account.creditTotal - account.debitTotal);
            break;
          case 'Expense':
            // Expense should be positive (debit > credit means expense incurred)
            account.balance = Math.max(0, account.debitTotal - account.creditTotal);
            break;
        }
      });
      
      // üÜï AGGREGATE PARENT AR ACCOUNT (1100) WITH ALL CHILD ACCOUNTS
      try {
        console.log('\nüîó Aggregating parent AR account (1100) with child accounts...');
        
        // Find the main AR account (1100)
        const mainARAccount = accountBalances['1100'];
        if (mainARAccount) {
          let totalARBalance = mainARAccount.balance;
          let totalARDebits = mainARAccount.debitTotal;
          let totalARCredits = mainARAccount.creditTotal;
          
          // Find all child AR accounts (1100-*)
          const childARAccounts = Object.keys(accountBalances).filter(code => 
            code.startsWith('1100-') && code !== '1100'
          );
          
          console.log(`üìä Found ${childARAccounts.length} child AR accounts: ${childARAccounts.join(', ')}`);
          
          // Aggregate child account balances
          childARAccounts.forEach(childCode => {
            const childAccount = accountBalances[childCode];
            if (childAccount) {
              totalARBalance += childAccount.balance;
              totalARDebits += childAccount.debitTotal;
              totalARCredits += childAccount.creditTotal;
              console.log(`   Child account ${childCode}: $${childAccount.balance}`);
            }
          });
          
          // Update the main AR account with aggregated totals
          mainARAccount.balance = totalARBalance;
          mainARAccount.debitTotal = totalARDebits;
          mainARAccount.creditTotal = totalARCredits;
          mainARAccount.aggregated = true;
          mainARAccount.childAccounts = childARAccounts;
          mainARAccount.totalWithChildren = totalARBalance;
          
          console.log(`‚úÖ Updated main AR account (1100) with aggregated balance: $${totalARBalance}`);
        }
      } catch (error) {
        console.error('‚ùå Error aggregating AR accounts:', error);
        // Don't throw error as this is not critical for balance sheet generation
      }
      
      // üÜï AGGREGATE PARENT DEPOSIT ACCOUNTS WITH ALL CHILD ACCOUNTS
      try {
        console.log('\nüîó Aggregating parent deposit accounts with child accounts...');
        
        // Aggregate account 2020 (Tenant Security Deposits)
        const mainDepositAccount = accountBalances['2020'];
        if (mainDepositAccount) {
          let totalDepositBalance = mainDepositAccount.balance;
          let totalDepositDebits = mainDepositAccount.debitTotal;
          let totalDepositCredits = mainDepositAccount.creditTotal;
          
          // Find all child deposit accounts (2020-*)
          const childDepositAccounts = Object.keys(accountBalances).filter(code => 
            code.startsWith('2020-') && code !== '2020'
          );
          
          console.log(`üìä Found ${childDepositAccounts.length} child deposit accounts: ${childDepositAccounts.join(', ')}`);
          
          // Aggregate child account balances
          childDepositAccounts.forEach(childCode => {
            const childAccount = accountBalances[childCode];
            if (childAccount) {
              totalDepositBalance += childAccount.balance;
              totalDepositDebits += childAccount.debitTotal;
              totalDepositCredits += childAccount.creditTotal;
              console.log(`   Child deposit account ${childCode}: $${childAccount.balance}`);
            }
          });
          
          // Update the main deposit account with aggregated totals
          mainDepositAccount.balance = totalDepositBalance;
          mainDepositAccount.debitTotal = totalDepositDebits;
          mainDepositAccount.creditTotal = totalDepositCredits;
          mainDepositAccount.aggregated = true;
          mainDepositAccount.childAccounts = childDepositAccounts;
          mainDepositAccount.totalWithChildren = totalDepositBalance;
          
          console.log(`‚úÖ Updated main deposit account (2020) with aggregated balance: $${totalDepositBalance}`);
        }
        
        // Aggregate account 2030 (Deferred Income - Advance Rent)
        const mainDeferredAccount = accountBalances['2030'];
        if (mainDeferredAccount) {
          let totalDeferredBalance = mainDeferredAccount.balance;
          let totalDeferredDebits = mainDeferredAccount.debitTotal;
          let totalDeferredCredits = mainDeferredAccount.creditTotal;
          
          // Find all child deferred accounts (2030-*)
          const childDeferredAccounts = Object.keys(accountBalances).filter(code => 
            code.startsWith('2030-') && code !== '2030'
          );
          
          console.log(`üìä Found ${childDeferredAccounts.length} child deferred accounts: ${childDeferredAccounts.join(', ')}`);
          
          // Aggregate child account balances
          childDeferredAccounts.forEach(childCode => {
            const childAccount = accountBalances[childCode];
            if (childAccount) {
              totalDeferredBalance += childAccount.balance;
              totalDeferredDebits += childAccount.debitTotal;
              totalDeferredCredits += childAccount.creditTotal;
              console.log(`   Child deferred account ${childCode}: $${childAccount.balance}`);
            }
          });
          
          // Update the main deferred account with aggregated totals
          mainDeferredAccount.balance = totalDeferredBalance;
          mainDeferredAccount.debitTotal = totalDeferredDebits;
          mainDeferredAccount.creditTotal = totalDeferredCredits;
          mainDeferredAccount.aggregated = true;
          mainDeferredAccount.childAccounts = childDeferredAccounts;
          mainDeferredAccount.totalWithChildren = totalDeferredBalance;
          
          console.log(`‚úÖ Updated main deferred account (2030) with aggregated balance: $${totalDeferredBalance}`);
        }
        
        // Aggregate account 2501 (Deferred Income - Rent)
        const mainRentDeferredAccount = accountBalances['2501'];
        if (mainRentDeferredAccount) {
          let totalRentDeferredBalance = mainRentDeferredAccount.balance;
          let totalRentDeferredDebits = mainRentDeferredAccount.debitTotal;
          let totalRentDeferredCredits = mainRentDeferredAccount.creditTotal;
          
          // Find all child rent deferred accounts (2501-*)
          const childRentDeferredAccounts = Object.keys(accountBalances).filter(code => 
            code.startsWith('2501-') && code !== '2501'
          );
          
          console.log(`üìä Found ${childRentDeferredAccounts.length} child rent deferred accounts: ${childRentDeferredAccounts.join(', ')}`);
          
          // Aggregate child account balances
          childRentDeferredAccounts.forEach(childCode => {
            const childAccount = accountBalances[childCode];
            if (childAccount) {
              totalRentDeferredBalance += childAccount.balance;
              totalRentDeferredDebits += childAccount.debitTotal;
              totalRentDeferredCredits += childAccount.creditTotal;
              console.log(`   Child rent deferred account ${childCode}: $${childAccount.balance}`);
            }
          });
          
          // Update the main rent deferred account with aggregated totals
          mainRentDeferredAccount.balance = totalRentDeferredBalance;
          mainRentDeferredAccount.debitTotal = totalRentDeferredDebits;
          mainRentDeferredAccount.creditTotal = totalRentDeferredCredits;
          mainRentDeferredAccount.aggregated = true;
          mainRentDeferredAccount.childAccounts = childRentDeferredAccounts;
          mainRentDeferredAccount.totalWithChildren = totalRentDeferredBalance;
          
          console.log(`‚úÖ Updated main rent deferred account (2501) with aggregated balance: $${totalRentDeferredBalance}`);
        }
        
      } catch (error) {
        console.error('‚ùå Error aggregating deposit accounts:', error);
        // Don't throw error as this is not critical for balance sheet generation
      }
      
      // Categorize into balance sheet sections with proper classification
      Object.values(accountBalances).forEach(account => {
        const balance = account.balance;
        
        // üÜï FIX: Skip ALL child accounts from balance sheet - only show parent accounts
        // This ensures balance sheet shows only parent accounts with aggregated totals
        if (this.isChildAccount(account.code)) {
          console.log(`‚è≠Ô∏è Skipping child account ${account.code} - only parent accounts shown in balance sheet`);
          return; // Skip this child account
        }
        
        // Use comprehensive category mapping to ensure all accounts are properly categorized
        const mappedCategory = this.mapAccountToCategory(account.code, account.name, account.type);
        console.log(`üîç Account ${account.code} (${account.name}): type=${account.type}, mapped=${mappedCategory}, balance=$${balance}`);
        
        switch (account.type) {
          case 'Asset':
            if (this.isCurrentAsset(account.code, account.name)) {
              balanceSheet.assets.current[account.code] = {
                name: account.name,
                balance: Math.max(0, balance),
                description: this.getAssetDescription(account.code, account.name),
                category: mappedCategory
              };
              balanceSheet.assets.totalCurrent += Math.max(0, balance);
              console.log(`‚úÖ Added to current assets: ${account.code} - ${account.name} = $${Math.max(0, balance)}`);
            } else {
              balanceSheet.assets.nonCurrent[account.code] = {
                name: account.name,
                balance: Math.max(0, balance),
                description: this.getAssetDescription(account.code, account.name),
                category: mappedCategory
              };
              balanceSheet.assets.totalNonCurrent += Math.max(0, balance);
              console.log(`‚úÖ Added to non-current assets: ${account.code} - ${account.name} = $${Math.max(0, balance)}`);
            }
            break;
            
          case 'Liability':
            if (this.isCurrentLiability(account.code, account.name)) {
              balanceSheet.liabilities.current[account.code] = {
                name: account.name,
                balance: Math.abs(balance), // Use absolute value for liabilities
                description: this.getLiabilityDescription(account.code, account.name),
                category: 'Current Liability'
              };
              balanceSheet.liabilities.totalCurrent += Math.abs(balance);
            } else {
              balanceSheet.liabilities.nonCurrent[account.code] = {
                name: account.name,
                balance: Math.abs(balance), // Use absolute value for liabilities
                description: this.getLiabilityDescription(account.code, account.name),
                category: 'Non-Current Liability'
              };
              balanceSheet.liabilities.totalNonCurrent += Math.abs(balance);
            }
            break;
            
          case 'Equity':
            if (account.code === '3000' || account.name.toLowerCase().includes('capital')) {
              balanceSheet.equity.capital = Math.abs(balance); // Use absolute value for capital
            } else if (account.name.toLowerCase().includes('retained') || account.name.toLowerCase().includes('earnings')) {
              balanceSheet.equity.retainedEarnings += Math.abs(balance); // Use absolute value for retained earnings
            } else {
              balanceSheet.equity.otherEquity += Math.abs(balance); // Use absolute value for other equity
            }
            break;
            
          case 'Income':
            // Income increases retained earnings
            balanceSheet.equity.retainedEarnings += balance;
            console.log(`üìà Income account ${account.code} (${account.name}): +$${balance.toLocaleString()} ‚Üí Retained Earnings: $${balanceSheet.equity.retainedEarnings.toLocaleString()}`);
            break;
            
          case 'Expense':
            // Expenses decrease retained earnings
            balanceSheet.equity.retainedEarnings -= balance;
            console.log(`üìâ Expense account ${account.code} (${account.name}): -$${balance.toLocaleString()} ‚Üí Retained Earnings: $${balanceSheet.equity.retainedEarnings.toLocaleString()}`);
            break;
        }
      });
      
      // AGGREGATE PARENT ACCOUNTS WITH CHILDREN (e.g., Account 2000 + child accounts)
      await this.aggregateParentChildAccounts(balanceSheet);
      
      // Debug: Show all accounts that were processed
      console.log('\nüìä BALANCE SHEET SUMMARY:');
      console.log('Current Assets:', Object.keys(balanceSheet.assets.current));
      console.log('Non-Current Assets:', Object.keys(balanceSheet.assets.nonCurrent));
      console.log('Current Liabilities:', Object.keys(balanceSheet.liabilities.current));
      console.log('Non-Current Liabilities:', Object.keys(balanceSheet.liabilities.nonCurrent));
      console.log('Equity:', Object.keys(balanceSheet.equity));
      
      // Debug: Show specific account processing for petty cash
      console.log('\nüîç PETTY CASH DEBUG:');
      const pettyCashAccounts = Object.values(accountBalances).filter(acc => 
        acc.code.startsWith('101') || acc.name.toLowerCase().includes('petty')
      );
      console.log('Petty cash accounts found:', pettyCashAccounts.map(acc => ({
        code: acc.code,
        name: acc.name,
        type: acc.type,
        balance: acc.balance,
        isCurrentAsset: this.isCurrentAsset(acc.code, acc.name)
      })));
      
      if (pettyCashAccounts.length === 0) {
        console.log('‚ùå NO PETTY CASH ACCOUNTS FOUND!');
      }
      
      // Calculate totals and ratios
      balanceSheet.assets.totalAssets = balanceSheet.assets.totalCurrent + balanceSheet.assets.totalNonCurrent;
      // Ensure liability totals are always positive
      balanceSheet.liabilities.totalLiabilities = Math.abs(balanceSheet.liabilities.totalCurrent + balanceSheet.liabilities.totalNonCurrent);
      // Ensure equity totals are always positive
      balanceSheet.equity.totalEquity = balanceSheet.equity.capital + balanceSheet.equity.retainedEarnings + balanceSheet.equity.otherEquity;
      
      // Calculate key ratios
      balanceSheet.workingCapital = balanceSheet.assets.totalCurrent - balanceSheet.liabilities.totalCurrent;
      balanceSheet.currentRatio = balanceSheet.liabilities.totalCurrent > 0 ? 
        balanceSheet.assets.totalCurrent / balanceSheet.liabilities.totalCurrent : 0;
      balanceSheet.debtToEquity = balanceSheet.equity.totalEquity > 0 ? 
        balanceSheet.liabilities.totalLiabilities / balanceSheet.equity.totalEquity : 0;
      
      // Validate accounting equation: Assets = Liabilities + Equity
      const accountingEquation = Math.abs(
        balanceSheet.assets.totalAssets - 
        (balanceSheet.liabilities.totalLiabilities + balanceSheet.equity.totalEquity)
      );
      
      if (accountingEquation > 0.01) {
        console.warn(`‚ö†Ô∏è Accounting equation imbalance: ${accountingEquation}`);
        
        // Calculate what equity should be based on Assets - Liabilities
        const calculatedEquity = balanceSheet.assets.totalAssets - balanceSheet.liabilities.totalLiabilities;
        const equityDifference = calculatedEquity - balanceSheet.equity.totalEquity;
        
        console.log(`üîç Accounting Equation Analysis:`);
        console.log(`  - Assets: $${balanceSheet.assets.totalAssets.toLocaleString()}`);
        console.log(`  - Liabilities: $${balanceSheet.liabilities.totalLiabilities.toLocaleString()}`);
        console.log(`  - Calculated Equity (Assets - Liabilities): $${calculatedEquity.toLocaleString()}`);
        console.log(`  - Actual Equity from Transactions: $${balanceSheet.equity.totalEquity.toLocaleString()}`);
        console.log(`  - Difference: $${equityDifference.toLocaleString()}`);
        
        // DO NOT auto-correct retained earnings - let it show the actual transaction-based value
        // This difference indicates either:
        // 1. Missing transactions
        // 2. Data entry errors
        // 3. Or legitimate accounting differences that need investigation
        
        balanceSheet.accountingEquation = {
          balanced: false,
          difference: accountingEquation,
          message: `Assets ‚â† Liabilities + Equity - Difference: $${equityDifference.toLocaleString()}. Retained Earnings show actual transaction values.`,
          autoCorrected: false,
          correctionAmount: 0,
          investigationRequired: true
        };
      } else {
        balanceSheet.accountingEquation = {
          balanced: true,
          difference: 0,
          message: 'Assets = Liabilities + Equity ‚úì'
        };
      }
      
      return balanceSheet;
      
    } catch (error) {
      console.error('‚ùå Error generating balance sheet:', error);
      throw error;
    }
  }

  /**
   * Generate Monthly Balance Sheet for React Component
   * This method provides the data structure expected by the React component
   */
  static async generateMonthlyBalanceSheet(year, residence = null, type = 'monthly') {
    try {
      console.log(`üìä Generating Monthly Balance Sheet for ${year}${residence ? ` for residence: ${residence}` : ' (all residences)'} - Type: ${type}`);
      
      const monthlyData = {};
      const annualSummary = {
        totalAnnualAssets: 0,
        totalAnnualLiabilities: 0,
        totalAnnualEquity: 0,
        totalAnnualCurrentAssets: 0,
        totalAnnualNonCurrentAssets: 0,
        totalAnnualCurrentLiabilities: 0,
        totalAnnualNonCurrentLiabilities: 0
      };
      
      // Generate balance sheet for each month
      for (let month = 1; month <= 12; month++) {
        const monthEndDate = new Date(year, month, 0); // Last day of the month
        const monthKey = month;
        
        try {
          let monthBalanceSheet;
          
          if (type === 'monthly') {
            // Calculate monthly activity (change from previous month)
            monthBalanceSheet = await this.generateMonthlyActivityBalanceSheet(year, month, residence);
          } else {
            // Calculate cumulative balance as of month end (default behavior)
            monthBalanceSheet = await this.generateBalanceSheet(monthEndDate, residence);
          }
          
          // Safety check: Ensure monthBalanceSheet has proper structure
          if (!monthBalanceSheet || !monthBalanceSheet.assets || !monthBalanceSheet.liabilities || !monthBalanceSheet.equity) {
            console.warn(`‚ö†Ô∏è Month ${monthKey}: monthBalanceSheet has incomplete structure, using fallback data`);
            monthBalanceSheet = {
              assets: { current: {}, nonCurrent: {}, totalCurrent: 0, totalNonCurrent: 0, totalAssets: 0, accumulatedDepreciation: 0 },
              liabilities: { current: {}, nonCurrent: {}, totalCurrent: 0, totalNonCurrent: 0, totalLiabilities: 0 },
              equity: { capital: 0, retainedEarnings: 0, otherEquity: 0, totalEquity: 0 },
              workingCapital: 0,
              currentRatio: 0,
              debtToEquity: 0
            };
          }
          
          // Structure the data as expected by the React component with enhanced structure
          monthlyData[monthKey] = {
            month: monthKey,
            monthName: monthEndDate.toLocaleDateString('en-US', { month: 'long' }),
            assets: {
              current: {
                cashAndBank: this.formatCashAndBankAccounts(monthBalanceSheet.assets.current),
                accountsReceivable: this.formatAccountsReceivable(monthBalanceSheet.assets.current),
                inventory: this.formatInventoryAccounts(monthBalanceSheet.assets.current),
                prepaidExpenses: this.formatPrepaidAccounts(monthBalanceSheet.assets.current),
                total: monthBalanceSheet.assets.totalCurrent || 0
              },
              nonCurrent: {
                propertyPlantEquipment: this.formatFixedAssets(monthBalanceSheet.assets.nonCurrent),
                accumulatedDepreciation: monthBalanceSheet.assets.accumulatedDepreciation || 0,
                total: monthBalanceSheet.assets.totalNonCurrent || 0
              },
              total: monthBalanceSheet.assets.totalAssets || 0
            },
            
            // Debug: Show what's in cashAndBank after formatting (move logs outside object construction)
            liabilities: {
              current: {
                accountsPayable: this.formatAccountsPayable(monthBalanceSheet.liabilities.current),
                accruedExpenses: this.formatAccruedExpenses(monthBalanceSheet.liabilities.current),
                tenantDeposits: this.formatTenantDeposits(monthBalanceSheet.liabilities.current),
                deferredIncome: this.formatDeferredIncome(monthBalanceSheet.liabilities.current),
                taxesPayable: this.formatTaxesPayable(monthBalanceSheet.liabilities.current),
                total: Math.abs(monthBalanceSheet.liabilities.totalCurrent || 0)
              },
              nonCurrent: {
                longTermLoans: this.formatLongTermLoans(monthBalanceSheet.liabilities.nonCurrent),
                otherLongTermLiabilities: this.formatOtherLongTermLiabilities(monthBalanceSheet.liabilities.nonCurrent),
                total: Math.abs(monthBalanceSheet.liabilities.totalNonCurrent || 0)
              },
              total: Math.abs(monthBalanceSheet.liabilities.totalLiabilities || 0)
            },
            equity: {
              capital: {
                accountCode: '3000',
                accountName: 'Owner\'s Capital',
                amount: monthBalanceSheet.equity.capital || 0 // Allow negative values for equity
              },
              retainedEarnings: {
                accountCode: '3100',
                accountName: 'Retained Earnings',
                amount: monthBalanceSheet.equity.retainedEarnings || 0 // Allow negative values for equity
              },
              otherEquity: {
                accountCode: '3200',
                accountName: 'Other Equity',
                amount: monthBalanceSheet.equity.otherEquity || 0 // Allow negative values for equity
              },
              total: monthBalanceSheet.equity.totalEquity || 0
            },
            summary: {
              totalAssets: monthBalanceSheet.assets.totalAssets || 0,
              totalLiabilities: Math.abs(monthBalanceSheet.liabilities.totalLiabilities || 0), // Ensure positive values for liabilities
              totalEquity: monthBalanceSheet.equity.totalEquity || 0, // Allow negative values for equity
              workingCapital: monthBalanceSheet.workingCapital || 0,
              currentRatio: monthBalanceSheet.currentRatio || 0,
              debtToEquity: monthBalanceSheet.debtToEquity || 0
            }
          };
          
          // Accumulate annual totals with safety checks
          annualSummary.totalAnnualAssets += monthBalanceSheet.assets.totalAssets || 0;
          annualSummary.totalAnnualLiabilities += Math.abs(monthBalanceSheet.liabilities.totalLiabilities || 0); // Ensure positive values for liabilities
          annualSummary.totalAnnualEquity += monthBalanceSheet.equity.totalEquity || 0; // Allow negative values for equity
          annualSummary.totalAnnualCurrentAssets += monthBalanceSheet.assets.totalCurrent || 0;
          annualSummary.totalAnnualNonCurrentAssets += monthBalanceSheet.assets.totalNonCurrent || 0;
          annualSummary.totalAnnualCurrentLiabilities += Math.abs(monthBalanceSheet.liabilities.totalCurrent || 0); // Ensure positive values for liabilities
          annualSummary.totalAnnualNonCurrentLiabilities += Math.abs(monthBalanceSheet.liabilities.totalNonCurrent || 0); // Ensure positive values for liabilities
          
        } catch (monthError) {
          console.error(`‚ùå Error generating balance sheet for month ${month}:`, monthError);
          // Provide empty data for failed months
          monthlyData[monthKey] = {
            month: monthKey,
            monthName: new Date(year, month - 1, 1).toLocaleDateString('en-US', { month: 'long' }),
            assets: { 
              current: { cashAndBank: {}, accountsReceivable: {}, inventory: {}, prepaidExpenses: {}, total: 0 }, 
              nonCurrent: { propertyPlantEquipment: {}, accumulatedDepreciation: 0, total: 0 }, 
              total: 0 
            },
            liabilities: { 
              current: { accountsPayable: {}, accruedExpenses: {}, tenantDeposits: {}, taxesPayable: {}, total: 0 }, 
              nonCurrent: { longTermLoans: {}, otherLongTermLiabilities: {}, total: 0 }, 
              total: 0 
            },
            equity: { 
              capital: { accountCode: '3000', accountName: 'Owner\'s Capital', amount: 0 }, 
              retainedEarnings: { accountCode: '3100', accountName: 'Retained Earnings', amount: 0 }, 
              otherEquity: { accountCode: '3200', accountName: 'Other Equity', amount: 0 }, 
              total: 0 
            },
            summary: { 
              totalAssets: 0, 
              totalLiabilities: 0, 
              totalEquity: 0, 
              workingCapital: 0, 
              currentRatio: 0, 
              debtToEquity: 0 
            }
          };
        }
      }
      
      // Calculate annual averages (divide by 12 for monthly average)
      annualSummary.totalAnnualAssets = Math.round(annualSummary.totalAnnualAssets / 12);
      annualSummary.totalAnnualLiabilities = Math.round(annualSummary.totalAnnualLiabilities / 12);
      annualSummary.totalAnnualEquity = Math.round(annualSummary.totalAnnualEquity / 12);
      annualSummary.totalAnnualCurrentAssets = Math.round(annualSummary.totalAnnualCurrentAssets / 12);
      annualSummary.totalAnnualNonCurrentAssets = Math.round(annualSummary.totalAnnualNonCurrentAssets / 12);
      annualSummary.totalAnnualCurrentLiabilities = Math.round(annualSummary.totalAnnualCurrentLiabilities / 12);
      annualSummary.totalAnnualNonCurrentLiabilities = Math.round(annualSummary.totalAnnualNonCurrentLiabilities / 12);
      
      const result = {
        success: true,
        data: {
          year: year,
          residence: residence || 'all',
          monthly: monthlyData,
          annualSummary: annualSummary
        },
        message: `Monthly balance sheet generated for ${year}${residence ? ` for residence: ${residence}` : ' (all residences)'}`
      };
      
      console.log(`‚úÖ Monthly Balance Sheet generated successfully for ${year}`);
      return result;
      
    } catch (error) {
      console.error('‚ùå Error generating monthly balance sheet:', error);
      throw error;
    }
  }

  /**
   * Generate Monthly Activity Balance Sheet (shows monthly changes, not cumulative balances)
   * This method calculates the change in balances for a specific month
   */
  static async generateMonthlyActivityBalanceSheet(year, month, residence = null) {
    try {
      console.log(`üìä Generating Monthly Activity Balance Sheet for ${year}-${month}${residence ? ` for residence: ${residence}` : ' (all residences)'}`);
      
      const monthStartDate = new Date(year, month - 1, 1); // First day of the month
      const monthEndDate = new Date(year, month, 0); // Last day of the month
      const monthKey = `${year}-${String(month).padStart(2, '0')}`;
      
      // Get transactions that occurred ONLY in this specific month
      const monthQuery = {
        date: { 
          $gte: monthStartDate, 
          $lte: monthEndDate 
        },
        status: 'posted'
      };
      
      if (residence) {
        monthQuery.residence = residence;
      }
      
      // Get all transactions for this month
      const monthTransactions = await TransactionEntry.find(monthQuery).sort({ date: 1 });
      
      console.log(`üîç Found ${monthTransactions.length} transactions for ${monthKey}`);
      
      // Initialize balance sheet structure for monthly activity
      const balanceSheet = {
        asOfDate: monthEndDate,
        residence: residence || 'all',
        assets: { 
          current: {}, 
          nonCurrent: {}, 
          totalCurrent: 0, 
          totalNonCurrent: 0, 
          totalAssets: 0,
          accumulatedDepreciation: 0
        },
        liabilities: { 
          current: {}, 
          nonCurrent: {}, 
          totalCurrent: 0, 
          totalNonCurrent: 0, 
          totalLiabilities: 0 
        },
        equity: { 
          capital: 0, 
          retainedEarnings: 0, 
          otherEquity: 0,
          totalEquity: 0 
        },
        workingCapital: 0,
        currentRatio: 0,
        debtToEquity: 0,
        message: 'Monthly activity balance sheet generated successfully'
      };
      
      // Get ALL accounts from the database to ensure none are missing
      const Account = require('../models/Account');
      const allAccounts = await Account.find().sort({ code: 1 });
      
      // Initialize account balances for monthly activity
      const accountBalances = {};
      
      // Initialize ALL accounts with zero balances first
      allAccounts.forEach(account => {
        accountBalances[account.code] = {
          code: account.code,
          name: account.name,
          type: account.type,
          debitTotal: 0,
          creditTotal: 0,
          balance: 0,
          description: account.description || '',
          category: account.category || 'Other'
        };
      });
      
      // Process ONLY the transactions that occurred in this month
      monthTransactions.forEach(entry => {
        if (entry.entries && Array.isArray(entry.entries)) {
          entry.entries.forEach(lineItem => {
            const accountCode = lineItem.accountCode;
            const accountName = lineItem.accountName;
            const accountType = lineItem.accountType;
            const debit = lineItem.debit || 0;
            const credit = lineItem.credit || 0;
            
            if (accountBalances[accountCode]) {
              accountBalances[accountCode].debitTotal += debit;
              accountBalances[accountCode].creditTotal += credit;
              // Update name and type from transaction if more recent
              if (accountName) accountBalances[accountCode].name = accountName;
              if (accountType) accountBalances[accountCode].type = accountType;
            } else {
              // Create account if not found in database (fallback)
              accountBalances[accountCode] = {
                code: accountCode,
                name: accountName || `Account ${accountCode}`,
                type: accountType || 'Asset',
                debitTotal: debit,
                creditTotal: credit,
                balance: 0,
                description: '',
                category: 'Other'
              };
            }
          });
        }
      });
      
      // Calculate net balance for each account (monthly activity)
      Object.values(accountBalances).forEach(account => {
        switch (account.type) {
          case 'Asset':
            account.balance = account.debitTotal - account.creditTotal;
            break;
          case 'Liability':
            account.balance = account.creditTotal - account.debitTotal;
            break;
          case 'Equity':
            account.balance = account.creditTotal - account.debitTotal;
            break;
          case 'Income':
            // Income should be positive (credit > debit means income earned)
            account.balance = Math.max(0, account.creditTotal - account.debitTotal);
            break;
          case 'Expense':
            // Expense should be positive (debit > credit means expense incurred)
            account.balance = Math.max(0, account.debitTotal - account.creditTotal);
            break;
        }
      });
      
      // Categorize into balance sheet sections
      Object.values(accountBalances).forEach(account => {
        const balance = account.balance;
        
        // Use comprehensive category mapping to ensure all accounts are properly categorized
        const mappedCategory = this.mapAccountToCategory(account.code, account.name, account.type);
        
        switch (account.type) {
          case 'Asset':
            if (this.isCurrentAsset(account.code, account.name)) {
              balanceSheet.assets.current[account.code] = {
                name: account.name,
                balance: Math.max(0, balance),
                description: this.getAssetDescription(account.code, account.name),
                category: mappedCategory
              };
              balanceSheet.assets.totalCurrent += Math.max(0, balance);
            } else {
              balanceSheet.assets.nonCurrent[account.code] = {
                name: account.name,
                balance: Math.max(0, balance),
                description: this.getAssetDescription(account.code, account.name),
                category: mappedCategory
              };
              balanceSheet.assets.totalNonCurrent += Math.max(0, balance);
            }
            break;
            
          case 'Liability':
            if (this.isCurrentLiability(account.code, account.name)) {
              balanceSheet.liabilities.current[account.code] = {
                name: account.name,
                balance: Math.abs(balance), // Use absolute value for liabilities
                description: this.getLiabilityDescription(account.code, account.name),
                category: 'Current Liability'
              };
              balanceSheet.liabilities.totalCurrent += Math.abs(balance);
            } else {
              balanceSheet.liabilities.nonCurrent[account.code] = {
                name: account.name,
                balance: Math.abs(balance), // Use absolute value for liabilities
                description: this.getLiabilityDescription(account.code, account.name),
                category: 'Non-Current Liability'
              };
              balanceSheet.liabilities.totalNonCurrent += Math.abs(balance);
            }
            break;
            
          case 'Equity':
            if (account.code === '3000' || account.name.toLowerCase().includes('capital')) {
              balanceSheet.equity.capital = Math.abs(balance); // Use absolute value for capital
            } else if (account.name.toLowerCase().includes('retained') || account.name.toLowerCase().includes('earnings')) {
              balanceSheet.equity.retainedEarnings += Math.abs(balance); // Use absolute value for retained earnings
            } else {
              balanceSheet.equity.otherEquity += Math.abs(balance); // Use absolute value for other equity
            }
            break;
            
          case 'Income':
            // Income increases retained earnings
            balanceSheet.equity.retainedEarnings += balance;
            break;
            
          case 'Expense':
            // Expenses decrease retained earnings
            balanceSheet.equity.retainedEarnings -= balance;
            break;
        }
      });
      
      // AGGREGATE PARENT ACCOUNTS WITH CHILDREN (e.g., Account 2000 + child accounts)
      await this.aggregateParentChildAccounts(balanceSheet);
      
      // Calculate totals and ratios
      balanceSheet.assets.totalAssets = balanceSheet.assets.totalCurrent + balanceSheet.assets.totalNonCurrent;
      // Ensure liability totals are always positive
      balanceSheet.liabilities.totalLiabilities = Math.abs(balanceSheet.liabilities.totalCurrent + balanceSheet.liabilities.totalNonCurrent);
      // Ensure equity totals are always positive
      balanceSheet.equity.totalEquity = balanceSheet.equity.capital + balanceSheet.equity.retainedEarnings + balanceSheet.equity.otherEquity;
      
      // Calculate key ratios
      balanceSheet.workingCapital = balanceSheet.assets.totalCurrent - balanceSheet.liabilities.totalCurrent;
      balanceSheet.currentRatio = balanceSheet.liabilities.totalCurrent > 0 ? 
        balanceSheet.assets.totalCurrent / balanceSheet.liabilities.totalCurrent : 0;
      balanceSheet.debtToEquity = balanceSheet.equity.totalEquity > 0 ? 
        balanceSheet.liabilities.totalLiabilities / balanceSheet.equity.totalEquity : 0;
      
      console.log(`‚úÖ Monthly Activity Balance Sheet generated for ${monthKey}`);
      return balanceSheet;
      
    } catch (error) {
      console.error('‚ùå Error generating monthly activity balance sheet:', error);
      throw error;
    }
  }

  // Enhanced helper methods for formatting data
  
  /**
   * Check if an account is a child account (has a parent account)
   * Child accounts follow patterns like: 1100-68b83cfd7021d4021c1f3363, 2000-001, etc.
   */
  static isChildAccount(accountCode) {
    // Check for common child account patterns
    if (accountCode.includes('-')) {
      return true; // Any account with a dash is likely a child account
    }
    
    // Check for specific parent-child patterns
    const parentChildPatterns = [
      /^1100-\w+$/,  // AR child accounts: 1100-studentId
      /^2000-\w+$/,  // AP child accounts: 2000-supplierId
      /^2020-\w+$/,  // Deposit child accounts: 2020-studentId
      /^2030-\w+$/,  // Deferred income child accounts: 2030-studentId
      /^2501-\w+$/,  // Deferred rent child accounts: 2501-studentId
      /^1000-\w+$/,  // Cash child accounts: 1000-locationId
      /^1500-\w+$/,  // Equipment child accounts: 1500-equipmentId
    ];
    
    return parentChildPatterns.some(pattern => pattern.test(accountCode));
  }
  
  static formatCashAndBankAccounts(currentAssets) {
    const cashAndBank = {};
    let total = 0;
    
    console.log('üîç formatCashAndBankAccounts - Processing current assets:', currentAssets);
    
    // Add null/undefined check to prevent "Cannot convert undefined or null to object" error
    if (!currentAssets || typeof currentAssets !== 'object') {
      console.warn('‚ö†Ô∏è formatCashAndBankAccounts: currentAssets is null/undefined, returning empty object');
      return { total: 0 };
    }
    
    Object.entries(currentAssets).forEach(([code, asset]) => {
      // Include ALL cash, bank, and petty cash accounts by code pattern
      if (code.startsWith('100') || code.startsWith('101')) {
        console.log(`‚úÖ Including account in cashAndBank: ${code} - ${asset.name} = $${asset.balance}`);
        
        cashAndBank[code] = {
          accountCode: code,
          accountName: asset.name,
          amount: asset.balance,
          description: asset.description || this.getAssetDescription(code, asset.name),
          category: asset.category || 'Current Asset'
        };
        total += asset.balance;
      } else {
        console.log(`‚ùå Excluding account from cashAndBank: ${code} - ${asset.name} = $${asset.balance}`);
      }
    });
    
    cashAndBank.total = total;
    console.log(`üí∞ cashAndBank total: $${total}`);
    console.log(`üìã cashAndBank accounts:`, Object.keys(cashAndBank));
    
    return cashAndBank;
  }

  static formatAccountsReceivable(currentAssets) {
    const accountsReceivable = {};
    
    // Add null/undefined check to prevent "Cannot convert undefined or null to object" error
    if (!currentAssets || typeof currentAssets !== 'object') {
      console.warn('‚ö†Ô∏è formatAccountsReceivable: currentAssets is null/undefined, returning empty object');
      return { total: 0 };
    }
    
    Object.entries(currentAssets).forEach(([code, asset]) => {
      // Look for any account that is an AR account (student-specific or generic)
      if (asset.name.toLowerCase().includes('receivable') || code.startsWith('1100')) {
        accountsReceivable[code] = {
          accountCode: code,
          accountName: asset.name,
          amount: asset.balance,
          description: asset.description,
          category: asset.category
        };
      }
    });
    
    // If no specific AR accounts found, create a default one
    if (Object.keys(accountsReceivable).length === 0) {
      accountsReceivable.default = {
        accountCode: '1100',
        accountName: 'Accounts Receivable - Tenants',
        amount: 0,
        description: 'Accounts receivable from tenants',
        category: 'Current Asset'
      };
    }
    
    return accountsReceivable;
  }

  static formatInventoryAccounts(currentAssets) {
    const inventory = {};
    
    // Add null/undefined check to prevent "Cannot convert undefined or null to object" error
    if (!currentAssets || typeof currentAssets !== 'object') {
      console.warn('‚ö†Ô∏è formatInventoryAccounts: currentAssets is null/undefined, returning empty object');
      return { total: 0 };
    }
    
    Object.entries(currentAssets).forEach(([code, asset]) => {
      if (asset.name.toLowerCase().includes('inventory') || asset.name.toLowerCase().includes('supplies')) {
        inventory[code] = {
          accountCode: code,
          accountName: asset.name,
          amount: asset.balance,
          description: asset.description,
          category: asset.category
        };
      }
    });
    
    return inventory;
  }

  static formatPrepaidAccounts(currentAssets) {
    const prepaid = {};
    
    // Add null/undefined check to prevent "Cannot convert undefined or null to object" error
    if (!currentAssets || typeof currentAssets !== 'object') {
      console.warn('‚ö†Ô∏è formatPrepaidAccounts: currentAssets is null/undefined, returning empty object');
      return { total: 0 };
    }
    
    Object.entries(currentAssets).forEach(([code, asset]) => {
      if (asset.name.toLowerCase().includes('prepaid')) {
        prepaid[code] = {
          accountCode: code,
          accountName: asset.name,
          amount: asset.balance,
          description: asset.description,
          category: asset.category
        };
      }
    });
    
    return prepaid;
  }

  static formatFixedAssets(nonCurrentAssets) {
    const fixedAssets = {};
    
    // Add null/undefined check to prevent "Cannot convert undefined or null to object" error
    if (!nonCurrentAssets || typeof nonCurrentAssets !== 'object') {
      console.warn('‚ö†Ô∏è formatFixedAssets: nonCurrentAssets is null/undefined, returning empty object');
      return { total: 0 };
    }
    
    Object.entries(nonCurrentAssets).forEach(([code, asset]) => {
      if (asset.name.toLowerCase().includes('property') || 
          asset.name.toLowerCase().includes('equipment') || 
          asset.name.toLowerCase().includes('building') ||
          asset.name.toLowerCase().includes('vehicle')) {
        fixedAssets[code] = {
          accountCode: code,
          accountName: asset.name,
          amount: asset.balance,
          description: asset.description,
          category: asset.category
        };
      }
    });
    
    return fixedAssets;
  }

  static formatAccountsPayable(currentLiabilities) {
    const accountsPayable = {};
    
    // Add null/undefined check to prevent "Cannot convert undefined or null to object" error
    if (!currentLiabilities || typeof currentLiabilities !== 'object') {
      console.warn('‚ö†Ô∏è formatAccountsPayable: currentLiabilities is null/undefined, returning empty object');
      return { total: 0 };
    }
    
    Object.entries(currentLiabilities).forEach(([code, liability]) => {
      if (liability.name.toLowerCase().includes('payable')) {
        accountsPayable[code] = {
          accountCode: code,
          accountName: liability.name,
          amount: Math.abs(liability.balance), // FIX: Ensure positive values for liabilities
          description: liability.description,
          category: liability.category
        };
      }
    });
    
    return accountsPayable;
  }

  static formatAccruedExpenses(currentLiabilities) {
    const accrued = {};
    
    // Add null/undefined check to prevent "Cannot convert undefined or null to object" error
    if (!currentLiabilities || typeof currentLiabilities !== 'object') {
      console.warn('‚ö†Ô∏è formatAccruedExpenses: currentLiabilities is null/undefined, returning empty object');
      return { total: 0 };
    }
    
    Object.entries(currentLiabilities).forEach(([code, liability]) => {
      if (liability.name.toLowerCase().includes('accrued')) {
        accrued[code] = {
          accountCode: code,
          accountName: liability.name,
          amount: Math.abs(liability.balance), // FIX: Ensure positive values for liabilities
          description: liability.description,
          category: liability.category
        };
      }
    });
    
    return accrued;
  }

  static formatTenantDeposits(currentLiabilities) {
    const deposits = {};
    
    // Add null/undefined check to prevent "Cannot convert undefined or null to object" error
    if (!currentLiabilities || typeof currentLiabilities !== 'object') {
      console.warn('‚ö†Ô∏è formatTenantDeposits: currentLiabilities is null/undefined, returning empty object');
      return { total: 0 };
    }
    
    Object.entries(currentLiabilities).forEach(([code, liability]) => {
      if (liability.name.toLowerCase().includes('deposit') || 
          liability.name.toLowerCase().includes('deferred') ||
          liability.name.toLowerCase().includes('unearned')) {
        deposits[code] = {
          accountCode: code,
          accountName: liability.name,
          amount: Math.abs(liability.balance), // FIX: Ensure positive values for liabilities
          description: liability.description,
          category: liability.category
        };
      }
    });
    
    return deposits;
  }

  static formatTaxesPayable(currentLiabilities) {
    const taxes = {};
    
    // Add null/undefined check to prevent "Cannot convert undefined or null to object" error
    if (!currentLiabilities || typeof currentLiabilities !== 'object') {
      console.warn('‚ö†Ô∏è formatTaxesPayable: currentLiabilities is null/undefined, returning empty object');
      return { total: 0 };
    }
    
    Object.entries(currentLiabilities).forEach(([code, liability]) => {
      if (liability.name.toLowerCase().includes('tax')) {
        taxes[code] = {
          accountCode: code,
          accountName: liability.name,
          amount: Math.abs(liability.balance), // FIX: Ensure positive values for liabilities
          description: liability.description,
          category: liability.category
        };
      }
    });
    
    return taxes;
  }

  static formatDeferredIncome(currentLiabilities) {
    const deferredIncome = {};
    
    // Add null/undefined check to prevent "Cannot convert undefined or null to object" error
    if (!currentLiabilities || typeof currentLiabilities !== 'object') {
      console.warn('‚ö†Ô∏è formatDeferredIncome: currentLiabilities is null/undefined, returning empty object');
      return { total: 0 };
    }
    
    Object.entries(currentLiabilities).forEach(([code, liability]) => {
      if (liability.name.toLowerCase().includes('deferred') || 
          liability.name.toLowerCase().includes('unearned') ||
          code === '2030') { // Specifically include account 2030
        deferredIncome[code] = {
          accountCode: code,
          accountName: liability.name,
          amount: Math.abs(liability.balance),
          description: liability.description,
          category: liability.category
        };
      }
    });
    
    return deferredIncome;
  }

  static formatLongTermLoans(nonCurrentLiabilities) {
    const loans = {};
    
    // Add null/undefined check to prevent "Cannot convert undefined or null to object" error
    if (!nonCurrentLiabilities || typeof nonCurrentLiabilities !== 'object') {
      console.warn('‚ö†Ô∏è formatLongTermLoans: nonCurrentLiabilities is null/undefined, returning empty object');
      return { total: 0 };
    }
    
    Object.entries(nonCurrentLiabilities).forEach(([code, liability]) => {
      if (liability.name.toLowerCase().includes('loan')) {
        loans[code] = {
          accountCode: code,
          accountName: liability.name,
          amount: Math.abs(liability.balance), // FIX: Ensure positive values for liabilities
          description: liability.description,
          category: liability.category
        };
      }
    });
    
    return loans;
  }

  static formatOtherLongTermLiabilities(nonCurrentLiabilities) {
    const other = {};
    
    // Add null/undefined check to prevent "Cannot convert undefined or null to object" error
    if (!nonCurrentLiabilities || typeof nonCurrentLiabilities !== 'object') {
      console.warn('‚ö†Ô∏è formatOtherLongTermLiabilities: nonCurrentLiabilities is null/undefined, returning empty object');
      return { total: 0 };
    }
    
    Object.entries(nonCurrentLiabilities).forEach(([code, liability]) => {
      if (!liability.name.toLowerCase().includes('loan')) {
        other[code] = {
          accountCode: code,
          accountName: liability.name,
          amount: Math.abs(liability.balance), // FIX: Ensure positive values for liabilities
          category: liability.category
        };
      }
    });
    
    return other;
  }
  
  // Enhanced helper methods for proper classification
  static isCurrentAsset(accountCode, accountName) {
    const currentAssetCodes = ['1000', '1010', '1011', '1012', '1013', '1014', '1100', '1200', '1300', '1400', '1500'];
    const currentAssetNames = ['cash', 'bank', 'petty', 'receivable', 'inventory', 'prepaid'];
    
    return currentAssetCodes.includes(accountCode) || 
           currentAssetNames.some(name => accountName.toLowerCase().includes(name));
  }
  
  // ‚úÖ NEW: Comprehensive account category mapping
  static mapAccountToCategory(accountCode, accountName, accountType) {
    // Map by account code pattern first (most reliable)
    if (accountCode.startsWith('100') || accountCode.startsWith('101')) {
      return 'Current Asset'; // Cash, Bank, Petty Cash
    } else if (accountCode.startsWith('110')) {
      return 'Current Asset'; // Accounts Receivable
    } else if (accountCode.startsWith('120')) {
      return 'Current Asset'; // Inventory
    } else if (accountCode.startsWith('130')) {
      return 'Current Asset'; // Prepaid Expenses
    } else if (accountCode.startsWith('200')) {
      return 'Current Liability'; // Accounts Payable, Deposits, etc.
    } else if (accountCode.startsWith('210')) {
      return 'Current Liability'; // Accrued Expenses
    } else if (accountCode.startsWith('300')) {
      return 'Equity'; // Capital, Retained Earnings
    } else if (accountCode.startsWith('400')) {
      return 'Income'; // Revenue accounts
    } else if (accountCode.startsWith('500')) {
      return 'Expense'; // Expense accounts
    }
    
    // Fallback to name-based mapping
    const nameLower = accountName.toLowerCase();
    if (nameLower.includes('cash') || nameLower.includes('bank') || nameLower.includes('petty')) {
      return 'Current Asset';
    } else if (nameLower.includes('receivable') || nameLower.includes('inventory') || nameLower.includes('prepaid')) {
      return 'Current Asset';
    } else if (nameLower.includes('payable') || nameLower.includes('deposit') || nameLower.includes('accrued')) {
      return 'Current Liability';
    } else if (nameLower.includes('capital') || nameLower.includes('equity') || nameLower.includes('earnings')) {
      return 'Equity';
    } else if (nameLower.includes('revenue') || nameLower.includes('income')) {
      return 'Income';
    } else if (nameLower.includes('expense') || nameLower.includes('cost')) {
      return 'Expense';
    }
    
    // Final fallback based on account type
    switch (accountType) {
      case 'Asset': return 'Current Asset';
      case 'Liability': return 'Current Liability';
      case 'Equity': return 'Equity';
      case 'Income': return 'Income';
      case 'Expense': return 'Expense';
      default: return 'Other';
    }
  }
  
  static isCurrentLiability(accountCode, accountName) {
    const currentLiabilityCodes = ['2000', '2010', '2020', '2030', '2040', '2100', '2200', '2300'];
    const currentLiabilityNames = ['payable', 'accrued', 'deposit', 'tax', 'deferred', 'unearned', 'short term'];
    
    return currentLiabilityCodes.includes(accountCode) || 
           currentLiabilityNames.some(name => accountName.toLowerCase().includes(name));
  }
  
  static getAssetDescription(accountCode, accountName) {
    if (accountCode === '1000' || accountName.toLowerCase().includes('cash')) {
      return 'Cash and cash equivalents';
    } else if (accountCode === '1010' || accountCode === '1011' || accountCode === '1012' || accountCode === '1013' || accountCode === '1014' || accountName.toLowerCase().includes('petty')) {
      return 'Petty cash funds for operational expenses';
    } else if (accountCode === '1100' || accountName.toLowerCase().includes('receivable')) {
      return 'Accounts receivable from tenants';
    } else if (accountCode === '1200' || accountName.toLowerCase().includes('inventory')) {
      return 'Inventory and supplies';
    } else if (accountCode === '1300' || accountName.toLowerCase().includes('prepaid')) {
      return 'Prepaid expenses';
    } else if (accountCode === '3000' || accountName.toLowerCase().includes('property')) {
      return 'Property and buildings';
    } else if (accountCode === '3100' || accountName.toLowerCase().includes('equipment')) {
      return 'Equipment and furniture';
    } else if (accountCode === '3200' || accountName.toLowerCase().includes('vehicle')) {
      return 'Vehicles and transportation';
    } else {
      return 'Other assets';
    }
  }
  
  static getLiabilityDescription(accountCode, accountName) {
    if (accountCode === '2000' || accountName.toLowerCase().includes('payable')) {
      return 'Accounts payable to suppliers';
    } else if (accountCode === '2100' || accountName.toLowerCase().includes('accrued')) {
      return 'Accrued expenses and liabilities';
    } else if (accountCode === '2200' || accountName.toLowerCase().includes('deposit')) {
      return 'Tenant security deposits';
    } else if (accountCode === '2300' || accountName.toLowerCase().includes('tax')) {
      return 'Taxes payable';
    } else if (accountCode === '2400' || accountName.toLowerCase().includes('loan')) {
      return 'Long-term loans and borrowings';
    } else {
      return 'Other liabilities';
    }
  }

  /**
   * Aggregate parent accounts with their child accounts (e.g., Account 2000 + children)
   */
  static async aggregateParentChildAccounts(balanceSheet) {
    try {
      console.log('\nüîó Aggregating parent-child accounts...');
      
      // Get the main Accounts Payable account (2000)
      const Account = require('../models/Account');
      const mainAPAccount = await Account.findOne({ code: '2000' });
      
      if (!mainAPAccount) {
        console.log('‚ö†Ô∏è Main Accounts Payable account (2000) not found');
        return;
      }

      // Get all accounts payable accounts (both children of 2000 and standalone AP accounts)
      const childAccounts = await Account.find({ 
        parentAccount: mainAPAccount._id,
        isActive: true
      });

      // Also get standalone accounts payable accounts that aren't children of 2000
      const standaloneAPAccounts = await Account.find({
        type: 'Liability',
        isActive: true,
        $or: [
          { name: { $regex: /accounts payable/i } },
          { code: { $regex: '^21' } } // Include 2100, 2101, 2102, etc.
        ],
        parentAccount: { $ne: mainAPAccount._id }
      });

      // Combine all accounts payable accounts
      const allAPAccounts = [...childAccounts, ...standaloneAPAccounts];

      console.log(`üìä Found ${childAccounts.length} child accounts for account 2000`);
      console.log(`üìä Found ${standaloneAPAccounts.length} standalone AP accounts`);
      console.log(`üìä Found ${allAPAccounts.length} total AP accounts`);
      
      // Calculate total balance for account 2000 including all AP accounts
      let totalAPBalance = 0;
      
      // Add main account 2000 balance
      if (balanceSheet.liabilities.current['2000']) {
        totalAPBalance += balanceSheet.liabilities.current['2000'].balance;
        console.log(`   Main account 2000: $${balanceSheet.liabilities.current['2000'].balance}`);
      }
      
      // Add all AP account balances (including children and orphaned accounts)
      for (const apAccount of allAPAccounts) {
        // Skip the main account 2000 as we already added it above
        if (apAccount.code === '2000') {
          continue;
        }
        
        if (balanceSheet.liabilities.current[apAccount.code]) {
          const accountBalance = balanceSheet.liabilities.current[apAccount.code].balance;
          totalAPBalance += accountBalance;
          const isChild = apAccount.parentAccount && apAccount.parentAccount.toString() === mainAPAccount._id.toString();
          const status = isChild ? 'CHILD' : 'ORPHANED';
          console.log(`   ${status} account ${apAccount.code}: $${accountBalance}`);
        }
      }
      
      console.log(`   Total aggregated balance: $${totalAPBalance}`);
      
      // Update the main account 2000 with the aggregated total
      if (balanceSheet.liabilities.current['2000']) {
        balanceSheet.liabilities.current['2000'].balance = totalAPBalance;
        balanceSheet.liabilities.current['2000'].aggregated = true;
        balanceSheet.liabilities.current['2000'].childAccounts = childAccounts.map(c => c.code);
        balanceSheet.liabilities.current['2000'].totalWithChildren = totalAPBalance;
        
        console.log(`‚úÖ Updated account 2000 with aggregated balance: $${totalAPBalance}`);
      }
      
      // Recalculate total current liabilities
      balanceSheet.liabilities.totalCurrent = Object.values(balanceSheet.liabilities.current)
        .reduce((total, liability) => total + liability.balance, 0);
      
      console.log(`‚úÖ Recalculated total current liabilities: $${balanceSheet.liabilities.totalCurrent}`);
      
    } catch (error) {
      console.error('‚ùå Error aggregating parent-child accounts:', error);
      // Don't throw error as this is not critical for balance sheet generation
    }
  }
}

module.exports = BalanceSheetService;



















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































